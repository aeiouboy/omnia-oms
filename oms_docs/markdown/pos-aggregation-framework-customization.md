# POS Metrics Customization - Aggregation Framework

**Permalink:** pos-aggregation-framework-customization
**Path:** Manhattan Active® Omni/Store/Process & Configuration Guides/Point of Sale/POS Classic Guides/POS Metrics - Aggregation Framework/POS Metrics Customization - Aggregation Framework
**Content Length:** 35,706 characters
**Scraped:** 2025-08-09T22:03:10.523102

---

Home ››Manhattan Active® Omni››Store››Process & Configuration Guides››Point of Sale››POS Classic Guides››POS Metrics - Aggregation Framework ››POS Metrics Customization - Aggregation Framework POS Metrics Customization - Aggregation Framework Customizing Aggregation Event in agg-omni componentFinding the right Aggregation EventWhat is not allowed to be modified in an aggregationEventAggregationEventGroupBy Cannot be changed as its the business key of TargetAuditEntity and TargetEntityWhat is allowed to be modified in an aggregationEventAdding new Aggregation Event RuleFields that are included in order payload sent to agg-omniCustomising ReportConfig Event in commonutil componentAllowed modification in reportConfigSample Use cases for customizationUse case 1: Ignore ecom sales calculation return metrics sent to net salesUse case 2: Ignore returns of sales from other storesUse case 3: Show new field Metrics captured using aggregation framework can be customized by services and end users. This space will provide the customization details and how to achieve the customization of metrics and all steps involved with it. Customizing Aggregation Event in agg-omni component Finding the right Aggregation Event Fetch the current aggregation event for entity using below API. GET - {{url}}/com-manh-cp-agg-omni/api/fw-entity-aggregation/aggregationEvent?query=EntitysName = '<Entity Name>' EntitysNameField = Order:  Querying based on Entity name will help in identifying the right aggregationEvent Eg : {{url}}/com-manh-cp-agg-omni/api/fw-entity-aggregation/aggregationEvent?query=EntitysName = 'Order' Sample aggregationEvent below SampleAggregationEvent { "EntitysName": "Order", "EventName": "ConfirmedOrderStats", "SourceUniqueKey": "OrderId", "AggregationEventRule": [ { "TargetEntity": "ConfirmedOrderStats", "TargetAuditEntity": "ConfirmedOrderStatsAudit", "RuleName": "ConfirmedOrderStatsRule", "SummarizationMsgType": "ConfirmedOrderStatsMsgType", "TemporalLevel": "Daily", "SourceTemporalFieldName": "CreatedTimestamp", "TargetTemporalFieldName": "AggregationDateTime", "LeafLevel": "Order", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel = 'Store' AND IsConfirmed = true AND IsPostVoid = false AND IsCancelled = false AND (MerchSaleLineCount > 0 OR MerchReturnLineCount > 0)" } ], "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderId", "SourceAggregationType": "Counter", "TargetFieldName": "MerchTotalOrderCount", "TargetAggregationType": "Sum" } ], "AggregationEventGroupBy": [ { "SourceFieldName": "Order.SellingLocationId", "TargetFieldName": "SellingLocationId" } ] } ] } What is not allowed to be modified in an aggregationEvent AggregationEventGroupBy Cannot be changed as its the business key of TargetAuditEntity and TargetEntity What is allowed to be modified in an aggregationEvent AggregationEventFilter can be modified. Existing condition can be modified to suit the needs. Sample: Removed the MerchSaleLineCount > 0 OR MerchReturnLineCount > 0 part from query AggregationEventFilter { "FilterPath": "Order", "FilterCondition": "SellingChannel = 'Store' AND IsConfirmed = true AND IsPostVoid = false AND IsCancelled = false" } Sample: Adding a new filter condition even on child entities is allowed as below. In this case make sure to change the LeafLevel (lowest level of grouping in the aggregation process) to OrderLine New Filter - Aggregation Event "LeafLevel": "OrderLine", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel = 'Store' AND IsConfirmed = true AND IsPostVoid = false AND IsCancelled = false AND (MerchSaleLineCount > 0 OR MerchReturnLineCount > 0)" }, { "FilterPath": "Order.OrderLine", "FilterCondition": "IsCancelled = false AND IsNonMerchandise = false AND IsReturn = false" } ] AggregationEventMeasure can be modified. Its an array and multiple EventMeasures can be added. Just note AggregationEventFilter condition will remain same for all AggregationEventMeasure's. If different filter condition is required add a new AggregationEventRule. New Targets can be added along with existing. Aggregation Event Measure "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderId", "SourceAggregationType": "Counter", "TargetFieldName": "MerchTotalOrderCount", "TargetAggregationType": "Sum" }, { "SourceFieldName": "Order.OrderLine.Quantity", "SourceAggregationType": "Sum", "TargetFieldName": "NbrOfMerchItemsSold", "TargetAggregationType": "Sum" } ] Target can be modified to point to another existing base field in TargetAuditEntity and TargetEntity. Aggregation - Modify Target { "SourceFieldName": "Order.OrderId", "SourceAggregationType": "Counter", "TargetFieldName": "<Existing Base entityfield>", "TargetAggregationType": "Sum" } Target can be modified to point to new Extended Attribute in TargetAuditEntity and TargetEntity. Make sure to add extended attribute in both TargetAuditEntity and TargetEntity. Aggregation - Modify target with new ext attribute "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderId", "SourceAggregationType": "Sum", "TargetFieldName": "Extended.SameStoreSaleCount", "TargetAggregationType": "Sum" } ] Adding new Aggregation Event Rule It is allowed to add new custom AggregationEventRule. While adding newAggregationEventRule, make sure to keep AggregationEventGroupBy same as that in base AggregationEventRule, as Group by fields is businessKey of TargetAuditEntity and TargetEntity and will not work correctly if different group by is used. New Aggregation Event Rule "AggregationEventRule":[ { "TargetEntity": "ConfirmedOrderStats", "TargetAuditEntity": "ConfirmedOrderStatsAudit", "RuleName": "ConfirmedOrderStatsRule", "SummarizationMsgType": "ConfirmedOrderStatsMsgType", "TemporalLevel": "Daily", "SourceTemporalFieldName": "CreatedTimestamp", "TargetTemporalFieldName": "AggregationDateTime", "LeafLevel": "Order", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel = 'Store' AND IsConfirmed = true AND IsPostVoid = false AND IsCancelled = false AND (MerchSaleLineCount > 0 OR MerchReturnLineCount > 0)" } ], "AggregationEventMeasure": [ { "SourceFieldName": "Order.Extended.SameStoreSaleCount", "SourceAggregationType": "Sum", "TargetFieldName": "Extended.SameStoreSaleCount", "TargetAggregationType": "Sum" } ], "AggregationEventGroupBy": [ { "SourceFieldName": "Order.SellingLocationId", "TargetFieldName": "SellingLocationId" } ] } ] Extended fields can be used as source fields Aggregation Event - Ext Field as source "AggregationEventMeasure": [ { "SourceFieldName": "Order.Extended.SameStoreSaleCount", "SourceAggregationType": "Sum", "TargetFieldName": "Extended.SameStoreSaleCount", "TargetAggregationType": "Sum" } ] SourceTemporalFieldName can be changed to use any dateTime field. Only BusinessDate with date field is allowed for now. Aggregation - SourceField "SourceTemporalFieldName": "UpdatedTimestamp" "SourceTemporalFieldName": "BusinessDate" Fields that are included in order payload sent to agg-omni Payload published by order component is controlled through below responseTemplate. If additional fields are required override the template at specific org level. For Example if we need to use Extended Attributes in AggregationEvent or reportConfig then add in this template. {url}/order/api/fwcore/responseTemplate/save Update theOrgId field in payload Aggregation - Order Payload to agg-omni { "TemplateId": "ConfirmedOrderStatsTemplate", "OrgId" : <OrganizationId for which template needs to be overridden> "TemplateJson": { "IsConfirmed": null, "IsCancelled": null, "IsPostVoided": null, "OrderId": null, "SellingChannel":null, "BusinessDate": null, "CreatedTimestamp": null, "MerchSaleLineCount": null, "MerchReturnLineCount": null, "CustomerId": null, "SellingLocationId": null, "OrganizationId": null, "OrderLine": { "IsCancelled": null, "IsNonMerchandise": null, "IsReturn": null, "OrderLineSubtotalWithDiscount":null, "OrderLineSubTotal": null, "TotalDiscountOnItem": null, "Quantity": null } } } Customising ReportConfig Event in commonutil component Do not remove any base ReportFieldConfig with FieldType as Input. It is not allowed to be modified in reportConfig. Allowed modification in reportConfig New ReportFieldConfig with fieldType as Input can be added. This can be added if additional filtering is needed while fetching records from TargetEntity. FieldName should be a field in all entities from which data is pulled, basically entities are GroupName of all ReportFieldConfig’s with FieldType Output and GroupName populated . New ReportFieldConfig with fieldType as Output and with either GroupName or Expression can be added. GroupName should be an entity present in agg-omni component and FieldName should be a filed in entity. Extended attribute field of TargetEntity can be configured as output Field with GroupName populated. It can be a new ReportFieldConfig or even base output ReportFieldConfig can be edited. Sample ReportFieldConfig below. {Url}/commonutil/api/commonutil/reportConfig/save Aggregation - Allowed reportConfig modification { "ReportName": "SaleMetricsReport", "Description": "Base Sale Metric Report", "PurgeAfterDays": 2555, "FetchRealTimeData": true, "ReportFieldConfig": [ { "FieldName": "Extended.SameStoreSaleCount", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "Integer" }, "DisplayName": "Total Order Count from Same Store", "GroupName": "ConfirmedOrderStats" } ] } In output SameStoreSaleCount will be returned without Extended. See example below. Aggregation - SameStoreSaleCount { "success": true, "header": null, "data": { "MerchTotalOrderCount": 6, "SameStoreSaleCount": 3 } } Above configured output field using Extended Attribute can be utilised in expressions. To have Extended field as an expression, modify the ReportConfig in commonutil. Make sure to remove “Extended.” from expressions. Eg below SameStoreSaleCount value is read from Extended.SameStoreSaleCount, but in expression it should have only SameStoreSaleCount. Any expressions supported by exp4j 0.4.8 API can be used. {URL}/commonutil/api/commonutil/reportConfig/save Aggregation - Using ext fields { "ReportName": "SaleMetricsReport", "Description": "Base Sale Metric Report", "PurgeAfterDays": 2555, "FetchRealTimeData": true, "ReportFieldConfig": [ { "FieldName": "Extended.SameStoreSaleCount", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "Integer" }, "DisplayName": "Total Order Count from Same Store", "GroupName": "ConfirmedOrderStats" }, { "FieldName": "FlashSales", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "BigDecimal" }, "Expression": "TotalOrderCount- abs(SameStoreSaleCount)", <Should remove Extended. and use only field in expressions.> "DisplayName": "Flash Sales" } ] } Sample Use cases for customization Use case 1: Ignore ecom sales calculation return metrics sent to net sales Custom Requirement : Net Sales = [Sales from my store today] – [Returns where the sale originated from any store] (If a original order is a ecom order which was returned in store, this should be ignored). Note, this should ignore/exclude any returns from sales that were made from a different channel (ecomm, call center) Challenge: Parent order details are not published by event producer Framework to agg-omni component. Only parentOrderId will be present in payload and whether return is from same store or ecom cannot be determined directly. Solution: Add an extended attribute in orderLine entity and populate it during order confirmation, say boolean field StoreSaleItem. ( Loop through all orderLines with IsReturn = True and determine if sale was performed from store. Fetch parent order using parentOrderId present in orderLine and verify if order is from store based on SellingChannel in OrderLine. Then populate Extended.StoreSaleItem field in OrderLine). Update ConfirmedOrderStatsTemplate responseTemplate in order to include extended attributes. . Refer What all fields are included in Order Payload sent to agg-omni section. FlashSales is shown in UI using the formula "MerchSaleItemsSubtotal- abs(MerchReturnItemsSubtotal)".ReportFieldConfig below { "FieldName": "FlashSales", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "BigDecimal" }, "Expression": "MerchSaleItemsSubtotal- abs(MerchReturnItemsSubtotal)", "DisplayName": "Flash Sales" } Modify AggregationEventRule in agg-omni aggregationEvent entity. Add StoreSaleItem field in OrderLine AggregationEventFilter. Change is in line 17 below Aggregation Framework - UseCase1 { "TargetEntity": "ConfirmedOrderLineStats", "TargetAuditEntity": "ConfirmedOrderLineStatsAudit", "RuleName": "MerchReturnItemsSubtotalRule", "TemporalLevel": "Daily", "SourceTemporalFieldName": "BusinessDate", "TargetTemporalFieldName": "AggregationDateTime", "LeafLevel": "Order.OrderLine", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel.SellingChannelId = 'Store' AND IsConfirmed = true AND IsPostVoided = false AND IsCancelled = false" }, { "FilterPath": "Order.OrderLine", "FilterCondition": "IsCancelled = false AND IsNonMerchandise = false AND IsReturn = true AND Extended.StoreSaleItem = true" } ], "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderLine.OrderLineSubtotalWithDiscount", "SourceAggregationType": "Sum", "TargetFieldName": "MerchReturnItemsSubtotal", "TargetAggregationType": "Sum" } ], "AggregationEventGroupBy": [ { "SourceFieldName": "Order.SellingLocationId", "TargetFieldName": "LocationId" } ] } Use case 2: Ignore returns of sales from other stores Custom requirement : Net Sales = [Sales from my store today] – [Returns where the sale originated from my store] (returns made were original order is not from current store should be ignored). Note, this should ignore/exclude any returns from sales that were made from a different channel (ecomm, call center) or from a different store Challenge: Parent order details are not published by event producer Framework to agg-omni component. Only parentOrderId will be present in payload and whether return is from same store or ecom cannot be determined directly. Solution: Add an extended attribute in orderLine entity and populate it during order confirmation, say boolean field SameStoreSaleItem. ( Loop through all orderLines with IsReturn = True and determine if sale was performed from same store. Fetch parent order using parentOrderId present in orderLine and verify if order is from same store based on SellingLocationId in parent order. Then populate Extended.SameStoreSaleItem field in OrderLine). Update ConfirmedOrderStatsTemplate responseTemplate in order to include extended attributes. . Refer What all fields are included in Order Payload sent to agg-omni section. FlashSales is shown in UI using the formula "MerchSaleItemsSubtotal- abs(MerchReturnItemsSubtotal)".ReportFieldConfig below { "FieldName": "FlashSales", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "BigDecimal" }, "Expression": "MerchSaleItemsSubtotal- abs(MerchReturnItemsSubtotal)", "DisplayName": "Flash Sales" } Modify AggregationEventRule in agg-omni aggregationEvent entity. Add SameStoreSaleItem field in OrderLine AggregationEventFilter.  Change is in line 17 below. Aggregation - UseCase2 { "TargetEntity": "ConfirmedOrderLineStats", "TargetAuditEntity": "ConfirmedOrderLineStatsAudit", "RuleName": "MerchReturnItemsSubtotalRule", "TemporalLevel": "Daily", "SourceTemporalFieldName": "BusinessDate", "TargetTemporalFieldName": "AggregationDateTime", "LeafLevel": "Order.OrderLine", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel.SellingChannelId = 'Store' AND IsConfirmed = true AND IsPostVoided = false AND IsCancelled = false" }, { "FilterPath": "Order.OrderLine", "FilterCondition": "IsCancelled = false AND IsNonMerchandise = false AND IsReturn = true AND Extended.SameStoreSaleItem = true" } ], "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderLine.OrderLineSubtotalWithDiscount", "SourceAggregationType": "Sum", "TargetFieldName": "MerchReturnItemsSubtotal", "TargetAggregationType": "Sum" } ], "AggregationEventGroupBy": [ { "SourceFieldName": "Order.SellingLocationId", "TargetFieldName": "LocationId" } ] } Use case 3: Show new field Custom requirement: Display new field Returns Total from same store in sale metrics screen. [Returns where the sale originated from my store] (returns made were original order is not from current store should be ignored). Note, this should ignore/exclude any returns from sales that were made from a different channel (ecomm, call center) or from a different store. Challenge: Parent order details are not published by event producer Framework to agg-omni component. Only parentOrderId will be present in payload and whether return is from same store or ecom cannot be determined directly. UI customisation is not supported currently to display additional fields on either Classic or Iris POS screens. Solution: Add an extended attribute in orderLine entity and populate it during order confirmation, say boolean field SameStoreSaleItem. ( Loop through all orderLines with IsReturn = True and determine if sale was performed from same store. Fetch parent order using parentOrderId present in orderLine and verify if order is from same store based on SellingLocationId in parent order. Then populate Extended.SameStoreSaleItem field in OrderLine). Update ConfirmedOrderStatsTemplate responseTemplate in order to include extended attributes. . Refer What all fields are included in Order Payload sent to agg-omni section. Modify AggregationEventRule in agg-omni aggregationEvent entity. Add SameStoreSaleItem field in OrderLine AggregationEventFilter.  Change is in line 17 below. Aggregation - Use case 3 modify event rule { "TargetEntity": "ConfirmedOrderLineStats", "TargetAuditEntity": "ConfirmedOrderLineStatsAudit", "RuleName": "MerchReturnItemsSubtotalRule", "TemporalLevel": "Daily", "SourceTemporalFieldName": "BusinessDate", "TargetTemporalFieldName": "AggregationDateTime", "LeafLevel": "Order.OrderLine", "AggregationEventFilter": [ { "FilterPath": "Order", "FilterCondition": "SellingChannel.SellingChannelId = 'Store' AND IsConfirmed = true AND IsPostVoided = false AND IsCancelled = false" }, { "FilterPath": "Order.OrderLine", "FilterCondition": "IsCancelled = false AND IsNonMerchandise = false AND IsReturn = true AND Extended.SameStoreSaleItem = true" } ], "AggregationEventMeasure": [ { "SourceFieldName": "Order.OrderLine.OrderLineSubtotalWithDiscount", "SourceAggregationType": "Sum", "TargetFieldName": "Extended.SameStoreMerchReturnItemsSubtotal", "TargetAggregationType": "Sum" } ], "AggregationEventGroupBy": [ { "SourceFieldName": "Order.SellingLocationId", "TargetFieldName": "LocationId" } ] } Add Extended Attribute in TargetEntity and TargetAuditEntity of agg-omni. In above example its the TargetFieldName that needs to be added as extended attribute in both entities which is Extended.SameStoreMerchReturnItemsSubtotal. Modify commonutil reportConfig and add a new Output ReportFieldConfig. If needs to be used as output add the first ReportFieldConfig entry alone.  If need to be used as an expression, then add both ReportFieldConfig as from below example. Aggregatioin - UseCase3 { "ReportName": "SaleMetricsReport", "Description": "Base Sale Metric Report", "PurgeAfterDays": 2555, "FetchRealTimeData": true, "ReportFieldConfig": [ { "FieldName": "Extended.SameStoreMerchReturnItemsSubtotal", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "Integer" }, "DisplayName": "Total Order Count from Same Store", "GroupName": "ConfirmedOrderStats" }, { "FieldName": "FlashSales", "FieldType": "Output", "FieldDataType": { "FieldDataTypeId": "BigDecimal" }, "Expression": "TotalOrderCount- abs(SameStoreMerchReturnItemsSubtotal)", <Should remove Extended. and use only field in expressions.> "DisplayName": "Flash Sales" } ] }