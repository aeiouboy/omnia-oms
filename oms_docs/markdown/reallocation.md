# Reallocation

**Permalink:** reallocation
**Path:** Manhattan Active® Omni/Order Management/Process & Configuration Guides/Order Processing/Order Fulfillment/Order Allocation/Batch/Re-allocation
**Content Length:** 42,049 characters
**Scraped:** 2025-08-09T21:57:13.848688

---

Home ››Manhattan Active® Omni››Order Management››Process & Configuration Guides››Order Processing››Order Fulfillment››Order Allocation››Batch ››Reallocation Reallocation Previous I How Reallocation WorksProcess FlowConfigurationEnabling ReallocationMod Queue-Based Reallocation for Improved Performance Before you begin: If your use case can be solved by continuous allocation, it is recommended to use it instead of the reallocation defined below. In general, re-allocation job should only run once a day. How Reallocation Works Reallocation is the process of reshuffling a set of orders prior to releasing for fulfillment by deallocating them (if needed) and allocating them using the batch allocation logic. This helps the higher priority orders to be allocated before allocating the lower priority orders. Also, helps to find out if there are any better supplies that can fulfill the priority orders. Reallocation enables the business to control which orders should get which inventory. There are multiple use cases to prioritize and reallocate orders: Direct to Consumer Orders over Wholesale, and Wholesale over Replenishment Replenishment Orders by Priority B2B/Wholesale Orders by Customer Based on Latest Ship Date / RDD vs First In First Out Allocate unallocated and backordered orders Allocate priority orders which are allocated against future inventory when new on hand inventory is available Reallocate orders to find a better location/supply based on the fulfillment optimization rules Note: It is important to note that the reallocation process is not aimed to be used only for transferring allocation from future to onhand inventory when the future inventory is received. This should be managed by Transfer allocation. Allocation to on hand inventory of order lines previously allocated to future inventory can happen during the reallocation process but it is not advised to use reallocation in place of transfer allocation Reallocation can be scheduled to run at a specific time interval and query can be defined based on order and order line attributes to filter orders for reallocation. Any order containing one order line selected by the scheduler will be selected for re-allocation and will either be fully or partially reallocated based on the reallocation scheduler configuration (see configuration section at the end of this guide for more information). If needed the reallocation job will deallocate the orders/order lines that are already allocated before invoking batch allocation process to prioritize the orders for allocation based on effective rank. Reallocation - Example 1Reallocate job is scheduled to pick up all Replenishment Orders (Open, Allocated, Back Ordered) and Customer Orders (Back ordered). Orders are as below. Order Order type Status Item Quantity Rank CO 1 Customer Order Allocated SKU A 5 1001 CO 2 Customer Order Back Ordered SKU A 5 1002 CO 3 Customer Order Released SKU A 5 1003 SO 1 Replenishment Order Open SKU A 10 2003 SO 2 Replenishment Order Allocated SKU A 10 2002 SO 3 Replenishment Order Back Ordered SKU A 10 2001 SO 4 Replenishment Order Released SKU A 10 2004 When Reallocation job runs, system picks up CO 2, SO 1, SO 2 and SO 3 for reallocation. Since SO 2 is already allocated, SO 2 is de-allocated first. Then, these orders are submitted for allocation based on the effective rank. In the below example, CO 2 is sent for allocation first followed by SO 3, SO 2 and SO 1 Process Flow Refer to Batch Allocation logic and How Allocation works for more details Configuration Enabling Reallocation Reallocation is configured by setting up a scheduler. The scheduler configuration and its multiple parameters are described below Reallocation configurationThe reallocation job type is: "reallocationJob" Reallocation Job schedule parameters Description Query Logical selection of order and order line attributes that will select the orders to be processed by the reallocation job. In the below example, the job will select all customer orders that have at least one line in backordered status (1500) and that have not been updated in the last 10 minutes. (OrderLine.MinFulfillmentStatusId IN('1500') and DocType.DocTypeId = 'CustomerOrder' and OrderLine.UpdatedTimestamp < CurrentTime(-10m) ) It is advised that before setting the reallocation job, the query is tested with a /search order API. Also note that quering on the grand child object is not supported. See below for more sample queries Reallocate Boolean flag that can be true or false. If it is set to true, the system will deallocate all the order lines that are part of the orders selected by the above query as long as they are not released. This can be used to make sure the orders are allocated from the optimal location by considering all the order lines in the reallocation process. If it is set to false, the order lines already allocated but part of the orders selected by the above query will not be deallocated and considered in the reallocation process. This can be used for two purposes: have the same logic as batch allocation or making sure that the already allocated inventory is not deallocated in case there is a risk if it gets stolen. However, in this case, there is a risk of order not getting allocated from the optimal location and would lead to split shipment. ReasonId (optional parameter) If an order is reallocated by the batch scheduler, within the QuantityDetail of the order, the system logs a Reason and a ReasonType to indicate what action caused a reallocation. If the active profile includes "Reason: ReAllocation", then this reason will be logged within the quantity detail when a ReAllocation scheduler reallocates an order (along with "ReasonTypeId: ReAllocation"). If the active profile does not include "Reason: Reallocation" then the reason logged in the quantity detail is "DeAllocation" and the ReasonTypeId is "InventoryDrop". The job parameter of the ReAllocate scheduler must have the ReasonId set to "ReAllocation" in order for the reason to be logged within the quantity detail. An example of reallocation scheduler Json configuration can be found below. This scheduler belongs to the profile purpose ord::batch in the order component. { "JobScheduleId": "reallocationJob", "JobTypeId": "reallocationJob", "CronExpression": "0 0 0/4 1/1 * ? *", "StartDelay": 1000, "RepeatInterval": 20000, "TriggerKey": "reallocationJobTrigger", "JobParameters": [ { "InputKey": "Query", "InputValue": "(OrderLine.MinFulfillmentStatusId IN('1500') and DocType.DocTypeId = 'CustomerOrder' and OrderLine.UpdatedTimestamp < CurrentTime(-10m) )" }, { "InputKey": "Reallocate", "InputValue": "true" }, { "InputKey": "ReasonId", "InputValue": "ReAllocation" } ] } Sample reallocation job queries: Level Attribute Sample Query Translation of the Sample Query in English Order Doc Type { "InputKey": "Query", "InputValue": "((DocType.DocTypeId = 'RetailOrder'))" } Reallocation will run only for Retail Orders having max fulfillment status less than Partially Released status. It considers all quantities in Open, Back ordered and Allocated status for reallocation. Order Order Line Doc Type Min Fulfillment Status { "InputKey": "Query", "InputValue": "((DocType.DocTypeId = 'RetailOrder') or (OrderLine.MinFulfillmentStatusId IN('1500') and DocType.DocTypeId = 'CustomerOrder'))" } Reallocation will run for both Customer and Retail Orders. For Retail Orders - All quantities in Open, Back ordered, and Allocated status is considered for reallocation. For Customer Orders - Only quantities in Back ordered status is considered for reallocation. Customer Order quantities which are allocated are not considered for reallocation Order Order Line Shipping Method { "InputKey": "Query", "InputValue": "((DocType.DocTypeId = 'RetailOrder') or (OrderLine.MinFulfillmentStatusId IN('1500') and DocType.DocTypeId = 'CustomerOrder') or (OrderLine.ShippingMethodId = 'Ground' and DocType.DocTypeId = 'CustomerOrder'))" } Reallocation will run for both Customer and Retail Orders. For Retail Orders - All  quantities in Open, Back ordered, and Allocated status is considered for reallocation. For Customer Orders - All quantities in Back ordered status is considered for reallocation. Customer Order line ( Back ordered and Allocated quantities) with Shipping method as Ground is considered for reallocation. Note: If status is not provided in the query then system considers only open and back ordered quantities for batch allocation. Note: Reallocation is different from batch allocation in the following aspects: Reallocation will deallocate the order first before trying to allocate them Reallocation can select orders with order lines in open, backorder or allocated status. Since Batch allocation does not deallocate, it cannot act on allocated order lines Reallocation can only be triggered by this scheduler, and the event based reallocation is not currently supported. Mod Queue-Based Reallocation for Improved Performance Using the "mod queue" based reallocation is not mandatory and depends on the volume of orders going through reallocation. The "Mod queue" based reallocation process has the exact same functionalities and only provides technical enhancements for reallocation runs with a large volume of orders. The need for this feature is driven by the time it takes to complete the reallocation job and not only the amount of orders going through reallocation. The length of the reallocation is also influenced by other parameters some of which being: the presence of extensions and integrations in the allocation process, the number of locations that are being considered for allocation, the volume of inventory records to sort through, the complexity of the allocation rules, and so on. In case of doubt if you need to enable this feature or not, please contact Manhattan Associate support. Mod queue based reallocation technical explanationIn non mod queue based reallocation, the system will select all the orders to reallocate and will process them in one message in the reallocation queue. With a large volume of orders this message can be massive and it can take a long time to deallocate all the order and allocate them. Because of the qproc design, if that message takes too long to process, the qproc will automatically restart and will start the processing of the message from scratch. After the restart, it is most likely that the message takes the same time to process and leads to another restart before the process starts all over again. To avoid this, mod queue based reallocation will not process all the orders to reallocate in a single transaction but will instead: Group the orders that have a similar set of items together to form what is called "item groups" After the deallocation of all the orders, instead of trying to reallocate immediately, it will post one message per order in "mod queues" One mod queue will contain all the orders of an item group. However, because the number of mod queues is limited, multiple item groups can be posted to the same mod queue. Instead of consuming one message with multiple orders, the system will have to consume 1 order per message. This removes the risk of having the qprocs restarted during the consumption of the message. Item grouping will be done with the same logic as used in the batch allocation process and will have the same limitations around hot SKUs. If an item is present in a large number of orders (promotional item for example), all these orders will be grouped together in one item group. This could lead to items groups being very different in size. However, even with this limitation, using mod queues will split the orders to have only one order per message even if they are all posted to the same queue. Note: Prioritization will be respected within an item group. However, just as batch allocation, the asynchronous nature of the process may lead to some lower priority orders to use a location capacity before the higher priority orders. Mod queue based reallocation will not call the normal batch allocation but will use multiple queues to process groups of orders simultaneously. Orders will be grouped by their item contents so that the orders with similar set of items will be allocated together. Configuring mod queue based reallocation starts with configuring the reallocation job as explained above. Once it is done, there are a few additional steps that needs to be performed. Mod queue based reallocation configuration - Queue Configuration1. Make sure the feature flag OM-40710#2020-03 is enabled. Contact a member of Manhattan Associates to confirm this. 2. Check if the below message types are configured in your active profiles. For memory, the message types belong to the below profile purposes: Entity Profile purpose InBoundMessageType ord::messaging OutBoundMessageType ord::messaging ExtPointToMessageType ord::processDefinition Create OutboundMessageTypes: {{url}}/order/api/ServiceDefinition/outBoundMessageType/import { "data": [ { "MessageType": "ReAllocationNoPriorityMSGType", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ReAllocationNoPriorityMSGType" } }, { "MessageType": "ModBasedMSGType1", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType1" } }, { "MessageType": "ModBasedMSGType2", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType2" } }, { "MessageType": "ModBasedMSGType3", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType3" } }, { "MessageType": "ModBasedMSGType4", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType4" } }, { "MessageType": "ModBasedMSGType5", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType5" } }, { "MessageType": "ModBasedMSGType6", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType6" } }, { "MessageType": "ModBasedMSGType7", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType7" } }, { "MessageType": "ModBasedMSGType8", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType8" } }, { "MessageType": "ModBasedMSGType9", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType9" } }, { "MessageType": "ModBasedMSGType10", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType10" } }, { "MessageType": "ModBasedMSGType", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType" } } ] } Create InBoundMessageTypes: {{url}}/order/api/ServiceDefinition/inBoundMessageType/import { "data": [ { "MessageType": "ModBasedMSGType1", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType1" } }, { "MessageType": "ModBasedMSGType2", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType2" } }, { "MessageType": "ModBasedMSGType3", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType3" } }, { "MessageType": "ModBasedMSGType4", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType4" } }, { "MessageType": "ModBasedMSGType5", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType5" } }, { "MessageType": "ModBasedMSGType6", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType6" } }, { "MessageType": "ModBasedMSGType7", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType7" } }, { "MessageType": "ModBasedMSGType8", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType8" } }, { "MessageType": "ModBasedMSGType9", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType9" } }, { "MessageType": "ModBasedMSGType10", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType10" } }, { "MessageType": "ModBasedMSGType", "NoOfConsumer": 0, "MinNoOfConsumer": 1, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType" } }, { "MessageType": "ReAllocationNoPriorityMSGType", "NoOfConsumer": 10, "MinNoOfConsumer": 1, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 6, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Queue for order lines with no priority", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ReAllocationNoPriorityMSGType" } } ] } Create ExtPointToMessageType: {{url}}/order/api/ServiceDefinition/extPointToMessageType/import { "data": [ { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType1", "MessageType": "ModBasedMSGType1" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType2", "MessageType": "ModBasedMSGType2" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType3", "MessageType": "ModBasedMSGType3" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType4", "MessageType": "ModBasedMSGType4" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType5", "MessageType": "ModBasedMSGType5" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType6", "MessageType": "ModBasedMSGType6" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType7", "MessageType": "ModBasedMSGType7" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType8", "MessageType": "ModBasedMSGType8" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType9", "MessageType": "ModBasedMSGType9" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType10", "MessageType": "ModBasedMSGType10" }, { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType", "MessageType": "ModBasedMSGType" }, { "ExtensionPointId": "Order:Order:Event:ReAllocationNoPriorityMSGType", "MessageType": "ReAllocationNoPriorityMSGType" } ] } Mod queue based reallocation configuration - Job configuration Reallocation Job schedule new parameters (optional parameters) Description NumberOfModQueues When this feature is activated, there is 20 extension points and 10 mod based queues. So, it is possible to create 10 more extra Mod based queues if required by creating seedData in outBoundMessage, inBoundMessage and extPointToMSGType and pass NumberOfModQueues which they want for reallocation job to use as below in jobParameter of respective reallocation jobSchedule. { "InputValue": "10", "InputKey": "NumberOfModQueues" } Make sure when InputValue is greater than 10, those many extra mod based queues are created. Default number of mod queues to use for allocation is configured to 5. User can change this configuration to maximum 20. Increasing this value will be useful when we have more number of itemGroups to process and to process them faster. If we have 50 itemGroups and 5 default no of mod queues defined, then each mod queue can process orders from 10 itemGroups. Be careful to the number of inventory and promising component instances. For 5 (default) mod queues, there should be at least 3 promising and inventory REST or ALL containers. Mod queue based reallocation configuration - How to create new Mod base queuesMaximum number of ModBasedQueues supported is 20. Create OutBoundMessageType → User can create queues by following naming convention for MessageType as ModBasedMSGType11, ModBasedMSGType12.......ModBasedMSGType20and QueueName as queue.ModBasedMSGType11, queue.ModBasedMSGType12........queue.ModBasedMSGType20 {{url}}/order/api/ServiceDefinition/outBoundMessageType/save { "MessageType": "ModBasedMSGType11", "Transactional": true, "PersistMessageToMsgStore": false, "OutBoundQueues": { "QueueName": "queue.ModBasedMSGType11" } } Create InBoundMessageType. → User can create listeners by following naming convention for MessageType as ModBasedMSGType11, ModBasedMSGType12.......ModBasedMSGType20 and QueueName as queue.ModBasedMSGType11, queue.ModBasedMSGType12........queue.ModBasedMSGType20 {{url}}/order/api/ServiceDefinition/inBoundMessageType/save { "MessageType": "ModBasedMSGType11", "NoOfConsumer": 1, "MinNoOfConsumer": 0, "Idempotent": true, "ExternalIntegrationRequired": false, "MaxDesiredInstances": 1, "ScaleUpTimeWindow": 10, "ScaleDownTimeWindow": 20, "Description": "Mod Based queue with single threaded listener.", "ServiceId": "ModBasedGenericService", "InBoundQueues": { "QueueName": "queue.ModBasedMSGType11" } } Create ExtPointToMsgType → Naming convention to be followed for ExtensionPointId is Order:Order:Event:{messageType} where messageType can have values from ModBasedMSGType11, ModBasedMSGType12.....ModBasedMSGType20 Naming convention for MessageType is ModBasedMSGType11, ModBasedMSGType12.....ModBasedMSGType20 {{url}}/order/api/ServiceDefinition/extPointToMessageType/save { "ExtensionPointId": "Order:Order:Event:ModBasedMSGType11", "MessageType": "ModBasedMSGType11" }