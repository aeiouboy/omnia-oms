# POS Payment Process

**Permalink:** pos-payment-process
**Path:** Manhattan Active® Omni/Store/Process & Configuration Guides/Point of Sale/POS Guides/POS Payment/POS Payment Process
**Content Length:** 94,123 characters
**Scraped:** 2025-08-09T22:02:03.495712

---

Home ››Manhattan Active® Omni››Store››Process & Configuration Guides››Point of Sale››POS Guides››POS Payment ››POS Payment Process Payment Process Payment ProcessCapturing PaymentPayment Captured at the Point of Sale (POS)Foreign (or alternate) CurrencyEMV dataDepositsPayment Capture ConfigurationCustom Tender CreationCustom Payment TypesPrivate Label Credit Card - Example of a custom payment typeConfiguring a Single Card Option for Both Credit and Debit PaymentsUser Input FormsTap To PayQR Code Digital Wallet PaymentsMobile RegistersScan Cash Drawer for mobile registersSharing Payment Terminals between Mobile RegistersPost Void/Cancel PaymentPost Void/Cancel ConfigurationExchange Tender (ET) TransactionsExchange tender limitations:Key configurations to perform Exchange TenderExchange Tender RestrictionsET - Associating a customerET - Charging the tender to be exchangedET - Payback processET - Receipt and ReprintGift card Cash outPartial Amount CapturePayment Terminal OfflineProcess FlowPayment Hardening and Failure HandlingRequestLogs/UniqueIdHardening workflowHandling Communication errorPrior to Release 23.1- Legacy Comm failure handling Following Release 23.1- Flexible Comm failure handlingDelay Receipt until Order ConfirmationOrder confirmation failureAsynchronous Order ConfirmationReconciliation Cart Refresh During Network IssuesLast Trans FunctionalityLast Transaction - Immediate RetryLast Transaction - On DemandPayment ReconciliationWork Flow of payment reconciliationReconciliation Process OutlineServices The Payment component processes payments for orders initiated on any channel, including e-commerce, point of sale (POS), or call center. During the life cycle of each order, the Payment component manages authorizations, settlements, and refunds through integration with payment gateways such as Adyen or PAYware Connect. If a payment is captured and authorized in the order capture system such as POS or e-commerce, then the Payment component performs follow-on re-authorizations, settlements and refunds against the initial authorization. The Payment component uses order data to determine the type of transactions that are required. Settlements are created for the value of the fulfilled items, and authorizations are created for those that are ordered but not yet shipped or picked up. For example, when an in-store purchase is made using a credit card, the Payment component attempts to settle for the value of the order. When an online order is placed using a credit card, the Payment component attempts to authorize for the value of the order and will settle the value when the order ships. Similarly, if a POS order includes both in-store purchase lines and ship to home lines, then the Payment component has the ability to settle only the in-store sale lines and authorize for the lines that are going to ship to the customer's home. This behavior is controlled by a configuration which will be discussed further in the sections below. Each order can be paid with an unlimited number of payment methods. Supported payment types include cash, check, credit card, debit card, e-check, gift card, PayPal, store credit, and Travelers' check. Additional payment types can be configured as required. Capturing Payment Payment Captured at the Point of Sale (POS) When orders are captured in store, POS processes payments and saves completed payment transactions in the Payment component. Since the terminal or mobile sled used to capture payments typically integrates directly with the payment terminals, POS does not use the Payment component to calculate or execute services to create and execute transactions. POS uses payment API's to identify all the supported payment methods for an order and displays information like, Balance Due, eligible payment methods based on configurations. Based on the payment method chosen, the configuration  also handles obtaining the authorization portion of the order if there are ship to home lines on the order. Balance Due The balance due is displayed on the cart when the user clicks on the checkout button. The balance due is computed as the sum of all the amounts, taking out any applicable refunds in case of an exchange and any partial payments that are already applied. Examples: 1. Simple sale transaction Let's say the order has two store sale lines of $10 and $20 each line, and the total tax is $0.15, the Balance due will be computed as $30.15 2. Partially paid transaction In the above example, the initial Balance Due is $30.15, Let's say the customer chooses to pay $10 in cash. When the cash transaction is applied, the Balance due is recalculated and updated to $20.15 3. Simple return transaction If the associate is processing a return transaction, and the price of the two lines being returned are $50 and $25 and tax is $1.15, then the Balance due is calculated and displayed as $-76.15. The balance due is also displayed in red font for refunds. 4. Simple exchange transaction If the associate is processing an exchange transaction for a customer who is returning an item at a price of $72 and is exchanging with an item that is $100, then the Balance due is computed as $28 Foreign (or alternate) Currency Note: Alternate (multi-currency) support is currently only available for Classic POS. EMV data The term EMV stands for Europay, MasterCard and Visa. EMV is a global standard for authenticating credit and debit card transactions with integrated circuit cards, or “chip cards” at capable point of sale (POS) terminals. Manhattan Active® Omni POS Receipts will be able to capture EMV data. EMV data should be divided into 2 parts i.e. EMV header and EMV secondary details. EMV data is configurable, retailers need to enable business flags to "Receipt Inc Emv Primary" and/or "Receipt Inc Emv Secondary" on receipt parameters to have this printed on the base POS receipts. If a transaction is made via chip card, all receipts must include the following EMV information in addition to standard receipt information. EMV Primary receipt data and related mapping to the metadata entity attributes. Link for sample receipt. EMV Primary Mapping Card Holder Verification Method PaymentTransactionEMVTags.EMV_CVM Transaction Sequence Counter PaymentTransactionEMVTags.EMV_TAG_9F41 Application Label PaymentTransactionEMVTags.EMV_TAG_50 AID (Application Identifier) PaymentTransactionEMVTags.EMV_TAG_4F TVR (Terminal Verification Results) PaymentTransactionEMVTags.EMV_TAG_95 IAD (Issuer Application Data) PaymentTransactionEMVTags.EMV_TAG_9F10 TSI (Transaction Status Indicator) PaymentTransactionEMVTags.EMV_TAG_9B ARC (Application Response Code) PaymentTransactionEMVTags.EMV_TAG_8A EMV Secondary receipt data and related mapping to the metadata entity attributes. Link for sample receipt. EMV Secondary fields Mapping Application Version Number PaymentTransactionEMVTags.EMV_TAG_9F09 Application Usage Control PaymentTransactionEMVTags.EMV_TAG_9F07 Application Identifier (AID) – card PaymentTransactionEMVTags.EMV_TAG_9F06 Issuer Action Code – Default PaymentTransactionEMVTags.EMV_TAG_9F0D TacDefault PaymentTransactionEMVTags.TAC_DEFAULT Issuer Action Code – Online PaymentTransactionEMVTags.EMV_TAG_9F0F Issuer Action Code – Denial PaymentTransactionEMVTags.EMV_TAG_9F0E Application Preferred Name PaymentTransactionEMVTags.EMV_TAG_9F12 CARD ENTRY MODE PaymentTransactionEMVTags.CARD_ENTRY_MODE Issuer Code Table Index PaymentTransactionEMVTags.EMV_TAG_9F11 Application Primary Account Number (PAN) Sequence Number PaymentTransactionEMVTags.EMV_TAG_5F34 Terminal Action Code – Denial PaymentTransactionEMVTags.TAC_DENIAL Transaction Type PaymentTransactionEMVTags.EMV_TAG_9C Transaction Date PaymentTransactionEMVTags.EMV_TAG_9A Point-of-Service (POS) Entry Mode PaymentTransactionEMVTags.EMV_TAG_9F39 Terminal Action Code – Online PaymentTransactionEMVTags.TAC_ONLINE Amount, Other (Numeric) PaymentTransactionEMVTags.EMV_TAG_9F03 Amount, Authorised (Numeric) PaymentTransactionEMVTags.EMV_TAG_9F02 EmvMode PaymentTransactionEMVTags.EMV_MODE Cryptogram Information Data PaymentTransactionEMVTags.EMV_TAG_9F27 Transaction Currency Code PaymentTransactionEMVTags.EMV_TAG_5F2A EmvChipIndicator PaymentTransactionEMVTags.EMV_CHIP_INDICATOR Dedicated File (DF) Name PaymentTransactionEMVTags.EMV_TAG_84 Application Interchange Profile PaymentTransactionEMVTags.EMV_TAG_82 Unpredictable Number PaymentTransactionEMVTags.EMV_TAG_9F37 Application Transaction Counter (ATC) PaymentTransactionEMVTags.EMV_TAG_9F36 Terminal Type PaymentTransactionEMVTags.EMV_TAG_9F35 Cardholder Verification Method (CVM) Results PaymentTransactionEMVTags.EMV_TAG_9F34 Terminal Capabilities PaymentTransactionEMVTags.EMV_TAG_9F33 TermId PaymentTransactionEMVTags.TERMID Interface Device (IFD) Serial Number PaymentTransactionEMVTags.EMV_TAG_9F1E Terminal Country Code PaymentTransactionEMVTags.EMV_TAG_9F1A Application Cryptogram PaymentTransactionEMVTags.EMV_TAG_9F26 Transaction Time PaymentTransactionEMVTags.EMV_TAG_9F21 MERCHID PaymentTransactionEMVTags.MERCHID Deposits Orders containing only Omni (STA/STS/PAS) items will qualify for partial payments (deposits). On the Order Summary screen, once a partial payment is made, the Deposit button will be available based upon a grant.  If the Deposit button is selected, the order will be marked as partially paid and the order will progress to the receipt screen.   From the Order Search screen, the order can be selected and viewed.  The Order Detail screen will indicate the order is awaiting further payment and an option will be available to make additional payments.   If an additional payment is selected, the Order Summary screen will be displayed with the previously applied payment(s) and allow for either partial or full payment. Note: This feature  requires the Upgraded Store Application.  See Upgraded Store Application for more information. Payment Capture Configuration The behavior of payment types at POS is configurable via the Payment Capture Configuration.  In addition to basic behavior, custom configurations can be added to base tenders as well as custom tenders.  See the POS Payment Configuration guide for details. The configurations will determine the following within the UI flow: Capture customer Information and Identity Documents Input Entry Required Input Entry Type Authorization required through payment terminal Franking required Capture denominations Pop cash drawer and include in drawer count Capture customer signature Delay Payment Terminal Session Until Time of Payment Pay By Link POS Note: Ability to delete base tender, part of user-created profile. Owner of that profile has full control to create/delete entries. Retailers can configure an order to be paid by credit/debit/gift card via an email link or QR code.   Instead of the customer swiping/tapping/inserting their card at the payment terminal, they can opt to have a link sent to them via email or scan a QR code at the POS terminal to access the payment link. To do this, the retailer must first configure the Pay By Link as described in POS Payment Configuration. Note: Pay by Link by SMS/Text is not currently supported out of base POS.  This would require further integration with a provider - for example, Twilio.  Base deployments should use the "hide" metadata extension provided to hide the SMS option on the Order Summary screen, as it is not relevant at this time. When an associate selects “Pay By Link", the options for how to send the link (email, QR CODE) will be displayed based upon configuration through extensions.  Providing an email  was previously entered in the transaction, it will be prepopulated for Pay By Link.   The opt-in preferences of the customer will not be checked for Pay By Link (i.e. if the customer opted out of email but asked to pay by link via email, the link will be sent via email).   All current POS error checking for email will be utilized. Once a valid email  is entered, the associate will select the “Send Link” option.  After the QR Code is scanned or the email is sent, the associate will advance to the “Waiting for Customer” screen, which has a cancel button in case the user wants to return to the checkout screen. From this point there are two paths. The customer successfully completes the payment on the Adyen hosted webpage OR User selects cancel on the “Waiting for customer” screen to return to check out and possibly get a different payment. If the customer attempts a payment on the Adyen web page and that payment fails or is declined, then the customer will see the error on the Adyen web page itself and will be able to retry the payment with the same or different payment method. During this process nothing happens on the POS UI - it just stays on the “Waiting for customer” screen. Pay By Link will be for positive totals only (in store, send sale, BOPIS, Ship to address) and uneditable for the entire amount due. Custom Tender Creation The default supported payment types include cash, check, credit card, debit, e-check, gift card, PayPal, store credit, and traveler's check. Additional custom payment types can be configured as required. Custom Payment Types Custom payment types can be added as required. Newly created payment types can be used for both purchases as well as refunds. The payment configuration indicates how to process the payment type. Private Label Credit Card - Example of a custom payment type A Private Label Credit Card (PLCC) is a custom integrated payment type which a client may accept as tender in store. PLCC payment processing is typically characterized as"Stored Value Services", no processing over major card brand networks, valid only with the brand. As such, PLCC is typically not subject to PCI-DSS stipulations. If the PLCC is processed over major card brand networks, is branded with a logo of a major card network, or is accepted outside of the client’s selling operations, the payment type may be subject to PCI-DSS. Please, coordinate between the client and MA legal team as needed. Configuring a Single Card Option for Both Credit and Debit Payments If your business needs to display only one card option in the payment screen to handle both Credit and Debit transactions, you can achieve this through the following configuration steps: Edit the Credit Card Configuration: Navigate to the Payment Type configuration section and select the Credit Card configuration to edit. Update the Display Name from "Credit Card" to "Card." Save the configuration. Remove the Debit Card Configuration: In the Payment Type configuration, delete the Debit Card configuration. Adjust the Payment Capture Settings for Credit Card: Go to the Payment Capture Configuration and select the Credit Card option. In the Payment Capture Configuration Detail tab, disable the flag labeled "Set payment type on gateway request." Save the configuration. Adjust the Payment Capture Settings for Debit Card: Go to the Payment Capture Configuration and select the Debit Card option. In the Payment Capture Configuration Detail tab, enable the flag labeled "Set payment type on gateway request." Save the configuration. After making these changes, the payment options screen will only display "Card" as an option, allowing customers to use either a Credit or Debit card on the terminal. During a return, the automatic refund options will display the card type as Debit if the order was paid with a Debit card and the Payment capture configuration for Debit card is required to process the automatic refund. User Input Forms User input forms are a framework using which a retailer can capture payment information for custom tenders as well as base payment methods like check, cash or credit card. A form is associated with a payment type via the payment capture configuration. The form also honors key configurations on input methods that are defined in the Payment capture configuration. For example, if the payment capture configuration for a payment type has the "Input required" flag enabled and the process through terminal flag disabled, then the form is displayed on the POS cart. Retailers can configure one or more forms and a sequence can be defined, to define the sequence of the forms. Each form can then have one or more fields. The data that is received from the forms is sent back to payment and is persisted as additional attributes. Base supported payment types that require an input form configuration are Gift card, Check and Cash. Credit card does not require any forms to be configured. For more information regarding configuring Payment related input forms including Gift Card see the POS Payment Configuration guide. Note: Payment forms do not support cloud implementation yet. Tap To Pay Tap to pay functionality on the iPhone allows users to pay through the iPhone itself, where the phone itself acts as a payment terminal and accepts payment using the NFC hardware support. When configured for your business, associates can accept in-store payments using Tap to Pay on iPhone within the Manhattan Active® Point of Sale, eliminating the need for a separate payment terminal. Customers can complete transactions using any NFC-enabled payment method, including: Credit or Debit cards that support Tap to Pay on iPhone Digital wallets such as Apple Pay and Google Pay NFC-enabled devices like the Apple Watch However, Follow on Refund (new payment method), Void tender (Create open void transaction), Omni transactions and Exchange tender are not supported for Tap to Pay currently. Users can use a payment terminal for these types of transactions. Note: Tap to Pay is only available when Adyen is used as the payment gateway. Note: The Tap to Pay screens are rendered by the Adyen SDK and the language in those pages are dependent on the language configured on the iPhone. QR Code Digital Wallet Payments Manhattan Active® Point of Sale supports QR code payments through Adyen payment terminals by allowing customers to scan a QR code to complete a transaction using digital wallets like Alipay, WeChat Pay, and other supported services. If the system can process card payments, associates can also accept QR code payments using this flow. This flow requires no additional integration work. Adyen supports multiple QR code payment flows, such as: 1. Initiate from Terminal 2. Initiate from POS App 3. Initiate from Barcode Scanner Currently, Manhattan Active® Point of Sale only supports Initiate from Terminal. Here’s how it works: User selects a payment method which requires electronic authorization/processing (i.e, Credit or Debit). The POS system sends a payment request to the Adyen terminal. Users need to select the scan QR code option on the payment terminal. The terminal generates and displays a QR code on its screen. The customer uses their mobile wallet app, such as Alipay or WeChat Pay, to scan the QR code. Once scanned, the payment is processed through Adyen’s system. The terminal receives a response, confirming whether the payment was successful or declined. This works for both Local and Cloud. For additional information on how it works and how to test OR code wallets, refer to the links below: Initiate from Terminal Testing QR code Wallets on Adyen. Note: Omni transactions are not certified with Digital Wallets, since Adyen does not support them yet. Mobile Registers Scan Cash Drawer for mobile registers The "Scan to Open Cash Drawer" feature allows users with mobile registers to scan a designated QR code or barcode on a cash drawer to unlock it and update the till.  This feature is designed to ensure that a user doesn't inadvertantly pop a cash drawer which is physically distant from the mobile register device, since the user must be close to the drawer to scan the bar code with the mobile device. The cash drawer should have a scannable code which the POS application can scan using a camera/USB or a bluetooth scanner. If successful, the cash drawer unlocks, allowing the user to enter cash, update the till and confirm changes before securely closing it. If the cash drawer is engaged or open, a Bypass Cash Drawer pop-up appears. For a sale transaction override return, the user can enter or scan the cash drawer on the payment page. For an automatic return, the user can scan or enter the cash drawer using the pop-up that appears when they click on the automatic refund section. This behavior is the same for gift card cashouts. Sharing Payment Terminals between Mobile Registers Retailers can configure mobile registers (only) to establish a session with a payment terminal at the time of payment, instead of at the beginning of an order.  This allows for multiple registers to share a single payment terminal, and also allows users to easily switch to a different terminal as needed. Users will see the connected payment terminal displayed on the Order Summary screen.  If no terminal is connected, the display will show "Select a Payment Terminal". With the correct permissions, users can tap the payment terminal drop-down. In the drop-down, users can select a payment terminal from a list of pre-configured terminals for the store.  If paring to the terminal is required, the user will then be prompted to do so, else this will act as a selection.  Once selected, the newly connected terminal will display in the screen header.  Additionally, the terminal will persist in the header until the terminal is again changed. Note: The POS Settings screen will not be updated with this new selection. The session for the device will not begin until the following: User selects a tender on Order Summary which requires the terminal to collect data or to process (credit, debit, gift card, etc.) The user selects to issue or reload a gift card from the Cart User selects a "from" exchange tender which requires a payment terminal. If a session is started in the Cart, due to a gift card activate or reload,  where "Activate Gift Card in Cart" is true, the session will not end until the transaction is complete. The same will hold true for Exchange tenders where the "from" tender requires the payment terminal. If a partial payment has been made which established a session, the session will not be released until the user voids the partial payment and either returns to the Cart or completes the transaction. A register will not be able to engage an associated payment terminal while the terminal is actively engaged with another register, but can do so after the session is terminated. If another user attempts to establish a session with a payment terminal that is currently engaged, they will be notified and can try again once the other register has completed its transaction, or they can again go into the payment terminal popup to switch to another payment device. The session release will occur after the receipt has been printed or emailed, and the terminal will then become available for the next transaction. Note: This feature is for mobile register type only. Fixed terminals will continue to start the session upon order initiation and will continue to be used for line display of items. Post Void/Cancel Payment Post voids occur when a customer or store associate wants to effectively invalidate an order. A post void most commonly occurs when a store associate has made a mistake in ringing up an order. Unlike voids, post voids can occur a couple of hours after the transaction has been completed, meaning that certain payment types such as traveler's check cannot be refunded back to the original traveler's check; instead, they are refunded via a different payment method like cash. To post void an order, use the Save Payment Header service with the payment header isCancelled flag set to true. When a payment header is post voided, the Payment component uses configuration to determine how to proceed for each payment method on the order.  Each payment type has a cancelRefundPaymentType configured, and this is used in the case of post voids. For example, the cancelRefundPaymentType for a credit card payment method could be credit card, and the cancelRefundPaymentType for check payment method could be cash. Note: Current limitations - Post void doesn't work if Cancel Refund Payment Type under Payment Capture Config is different from the selected tender.  Post-void is supported for Credit Card and Paper tender type only. Post Void/Cancel Configuration Indicates the behavior when a payment is canceled during a Post Void in POS.  For example, some payment types such as cash should have an open void transaction created, so POS can issue cash to the customer and close the transaction. Other payment types like credit cards can have void transactions created and executed in the gateway immediately, since no follow-up action is required by POS. Possible values for cancel behavior include: New payment method: When a payment method of this payment type is canceled, a new payment method gets created to issue a refund for any closed settlement amounts. For example, follow-on voids against Traveler’s Check are not supported as checks cannot be given back to the customer.  So, instead of creating a cancel transaction, this flag tells the payment component to create a new payment method. The new payment type is created based on the payment capture configuration called 'Cancel Refund Payment Type.' Create and process cancel against original payment method: When a payment method of this payment type is canceled, a follow-on void gets created for each closed settlement and refund transaction. The cancel transaction is immediately sent to the gateway to be processed, and the payment header response includes the details of the outcome. For example, when a credit card with a closed settlement is canceled, a follow-on cancel is created against the settlement and executed in the gateway. Create open cancel against original payment method: When a payment method of this payment type is canceled, a follow-on void gets created for each closed settlement and refund transaction. The cancel transaction is not sent to a gateway, but instead is left open, so that POS can perform actions and close the transaction. For example, when a cash payment with a closed settlement is canceled, an open follow-on cancel is created against the settlement, and POS is expected to close the cancel transaction after issuing cash to the customer. Note:  Post-voiding does not reopen the user input form for payment types that required it during the initial payment process.  For example, during check payments, the check details are captured during the payment process. When post-voiding the same transaction, the customer is not required to re-enter the check information. As a result, the user input form will not be displayed during the post-voiding process. Exchange Tender (ET) Transactions Exchange tender in Active Store solution offers the retailers to accept a tender and refund the customer with another tender. Both the tenders i.e. the tender exchanged and the list of available refunded tender are configurable. The exchange refunded will be the same amount the tender is worth or the customer is charged on the tender to be exchanged. Exchange tender cannot be done partially and is always done for the full amount available on the tender to be exchanged. Exchange tender is a separate transaction by itself and cannot be combined in any existing sale/return/gift card/backoffice transactions. This feature is controlled by a specific UI grant, "ui::posservice::exchangetender".  Users with grant can perform this transaction else the menu option is not available. Every such transaction allows multiples of a single tender type to be exchanged. A typical exchange tender flow is mentioned below: Select EXCHANGE TENDER function.  Application generates a unique exchange tender transaction ID when Exchange Tender option is selected. Select the type of tender to be exchanged. (This is dependent on the configuration; only applicable tenders can be exchanged). Accept the tenders to be exchanged and get the balance available on this tender from either third-party or from payware or based on the user input configurations. The maximum amount allowed to be exchanged is based on configuration. Any amount above this is not allowed. Charge/settle the full funds from the tender to be exchanged. (Partial processing of funds is not supported.) Get the list of eligible refund tenders. This is the list of tender types to which the amounts get refunded to. Select the refund tender and enter the amount to be refund and process the refund. Refund can be split across different tender types. If any of the tender types requires to be placed in/out of cash drawer, then cash drawer opens when the refund balance=0. Exchange tender limitations: A completed exchange tender transaction cannot be post voided. Exchange tender transaction is not eligible to be returned or exchanged. Exchange tender transactions cannot be suspended. Tenders with no balance are not eligible for exchange and is not accepted on UI as a valid tender. Different types of tenders cannot be exchanged under the same exchange tender transaction. Key configurations to perform Exchange Tender The following configurations in Payment Capture Config are essential to perform an excahnge tender transaction maxFromExchangeTender permitFromExchangeTender permitToExchangeTender fromExchangeTenderDisplaySequence isBalEqReqForExchangeTender If a transaction ID was generated incorrectly or by accident, then the exchange tender transaction can be voided.  If a tender is added to transaction and customers wants to remove, it can be selected and voided from the transaction before charging funds from the tenders. Exchange Tender Restrictions The following payment types are not supported to be exchanged from and exchanged to E-Check Traveler's Check Debit Check Credit Card ET - Associating a customer Exchange tender transaction can be linked to a customer. At any point in the exchange tender transaction, the POS user can attach a customer to the transaction. Once any customer is linked it cannot be modified further to change to another customer. ET - Charging the tender to be exchanged When all the tenders to be exchanged are added in the exchange tender screen, user can click on Proceed. On clicking proceed, each tender is picked one at a time in the order in which they were added for charging.  The removal of refunds is the amount available on the tenders and this will create a settlement records for every tender added on the payment component. Error handling: If the only tender which is to be exchanged fails and retailer is not able to remove funds then app will error out and associate cannot proceed, then the associate either needs to retry or void this tender/transaction. Else if some amount of the tender to be exchanged fails and there is still some positive amount that was removed from the tender and needs to be refunded, then the associate will be proceeded to the Summary screen to allow the refund. ET - Payback process Based on the configuration, only selected tender is eligible as refund tender. And each tender has a maximum amount. Any amount above maximum limit is not allowed to be refunded for a selected refund tender. User can choose to split the refund across multiple tenders based on the configuration. Handling cash drawer and till updates: If any refund tender requires engaging a cash drawer (config, popCashDrawer=TRUE), then cash drawer is opened and funds are removed from the cash drawer and closed. Till is also updated in the backoffice for the specific amount drawn from the till. If the tender which is to be exchanged requires engaging a cash drawer, then cash drawer is opened and funds are inserted into the cash drawer and closed. Till is also updated in the backoffice for the specific amount inserted into the till. If the tender which is to be exchanged does not require engaging a cash drawer but requires only till updates i.e. includeDrawerCount = TRUE, then cash drawer is not engaged but funds are inserted into the cash drawer. Only till updates are performed in the backoffice for the specific amount inserted into the till. ET - Receipt and Reprint Once all the amount is refunded and the balance to be refunded = 0, then the application navigates to the receipt screen. User can choose to print or email the exchange tender transaction. The receipt contains list of tenders from where the funds are transferred to with the amount details and the list of tenders to which the funds are transferred along the amount details. Note: Reprinting of an exchange tender transaction is supported using reprint last transaction or from the customer purchase history screen. If "Capture customer Info" or "Capture Cust Id" is turned ON for specific tender, then for Exchange Tender scenario we will skip these screens as it is not applicable. Exchange Tender transaction are all non-taxable. Gift card Cash out When gift card is used to tender a transaction and its remaining balance goes very low, retailer can provide the ability to cash this out. As a result of this, the customer does not have to carry gift card with low balance on it.  This also reduces the number of active gift cards the retailer must maintain.  In case there is any balance to be satisfied, the system tries to apply the remaining gift card amount towards this and the rest gets cashed out.  The balance amount which is eligible for cash out is configurable under payCaptureConfig.CashOutThreshold. GC cashout always returns money to customer in the form of Cash It's not configurable. Once tendered, the system validates the remaining balance with the threshold defined.  If it has reached the eligible balance, prompts the option to cash out.  If the customer chooses to, the balance amount is settled and gets utilized towards the remaining balance to be satisfied or cash out. Example: The threshold limit is set to 5.00.  Customer uses a Gift card with 100.00 balance, pays 98.00, Order balance due=98.00.  With this, the balance remaining is 2 which is eligible for cash out.  If customer chooses the cash out option, 2.00 cash is handed over. Gift card cash out is applicable to "Gift Card" payment type and to "Store/merchadise credit" but not applicable to any other payment type. Partial Amount Capture When a payment is requested to the gateway, if the customer uses a debit card or a gift card to pay, it is possible for the gateway to only approve and settle a partial amount depending on the balance available on the card. For example, let's say the customer purchases products worth $75, the customer has a gift card and is intending to use the gift card to pay for as much as possible. When the user selects the gift card payment, the application will make a request to the payment gateway to capture $75. Let's say the gift card only has a balance of $30, the gateway can respond back with a successful response for $30. In this scenario, when the payment transaction is created in the application, a check is performed to check if the processed amount is less than the requested amount and if that's true, then the payment method amount is updated to the processed amount. The application will then show the $30 as applied tender for gift card on the checkout page and the user can then collect the remaining $75 using another payment method per the customer's choice. The POS application handles the partial amount capture only for payment methods that are configured to process through the terminal. If the payment type is configured as processed in the backend (PTT = False), then it is the responsibility of the implementation team. In the callgateway UE if the gateway responds with ProcessedAmount < RequestedAmount, then the custom code must also populate the transient flag RecomputePaymentMethodAmount to true in the response from the UE to base. Then the payment component will automatically update the PM.Amount based on the ProcessedAmount. Payment Terminal Offline There can be situations wherein a payment terminal / payment collecting device is unable to connect to payment systems to process tenders.  As an alternate, transactions go through tendering without the actual approval from the payment system. This is subjected to the floor limit being met by the transaction. This is referred to as Store and Forward (SAF). In case the floor limit is not met, system prompts the user to go for voice authorization, if configured. Store and Forward (SAF): Ability to allow payment transactions to be stored on the payment terminal if they meet the floor limit configured in the payment terminal. Voice Authorization: Process to get the authorization for the credit card tendering, in case the payment terminal is not able to contact the processors and SAF criteria are not met.  In this case, the store associate calls up the support, provides the card details and gets a response.  If this is approved, an authorization code is also provided, which the store associate enters on the POS application. Floor limit: It is the maximum amount allowed per transaction or per day.  If these criteria are not met, the payment terminal does not create a SAF transaction.  Instead, it prompts the user to proceed with voice authorization. SAF_NUM: It is the number returned, instead of CTROUTD/TROUTD, when a transaction has been put under SAF. Process Flow The user swipes their credit card on the terminal. The terminal tries to contact the payment system to get it processed.  In case it goes successfully, SAF flow is not triggered.   In case it does not go through, the terminal saves the request in device SAF storage and compares the floor limit specified. If the floor limit is met, save within the terminal, and provide the response with the SAF number to the POS application. In case the floor limit is not met, an error code is generated.  The POS application prompts the user to proceed with Voice Authorization, if configured.  Else, you cannot proceed with the current payment. Once voice authorization is obtained, the system moves it to SAF transaction storage.  Thus, payments with Voice Authorization are also treated similarly to offline payments under the floor limit, which were stored in SAF.  Both records have SAF numbers. The response is saved in payment with Store and Forward number Payment Hardening and Failure Handling Especially for payment types such as Credit, Debit, or Gift Cards which require authorization via a payment terminal and payment gateway, there can be scenarios during the day in a store, where transactions can be abandoned during a payment capture process due to various reasons such as (battery drain, network issues, gateway error etc) and thus the response from payment gateway is not captured on Manhattan Active solution.  Depending on the failure, in these cases the user may able to attempt payment with another tender, but sometimes the transaction must be abandoned.  If the customer has started interaction with the payment terminal prior to the network, device, or gateway failure, in such scenarios application would not know if the customer was charged on the gateway to start any process of reverting the payment. This problem will be systematically handled by capturing the payment request as logs before making the call to gateway and subsequently calls. When there are any discrepancies, the logs can be queried for all unconfirmed payments and checked with the gateway for any delta for reconciliation. RequestLogs/UniqueId As mentioned above all payment request needs to be save before placing the call to payment gateway or Manhattan Active solution. The needs to be logs are saved at every touch point with the gateway and payment component. Please refer the above workflows for various touch points. Also check below the life cycle of the requestLog for any payment transaction. Create an uniqueId, well known as referenceId which needs to be saved on requestLogs entity and same id is sent as part of all payment request to the gateway and to payment transaction on cloud server. UniqueId is required to identify the payment on gateway and map that with the payment transaction on cloud server. This mapping will help to find the discrepancies for further reconciliation. Before making a call to MX terminal - Create requestLogs data in "Created" status along with uniqueId and payment request to be sent to gateway. If MX terminal is used flag, processThroughTerminal = TRUE, and if 3rd party application is used, then flag processThroughThirdParty = TRUE while saving the data to requestLogs. After successful response from gateway - Save the response from gateway for the same uniqueId for which the request was sent and update the status as "Processed". Use this uniqueId from gateway and create request to save this uniqueId as paymentTransactionId on Manhattan Active solution (payment component). (For example: AddTender API) After successful response from Manhattan Active solution (payment component), save the response on requestLogs as "Completed". Note: The base mapping to save gateway response on Manhattan Active solution (payment component) is with respect to "Payware connect", if retailers are using other gateway then refer user exits documentation to handle mapping to save the payment transaction. The plugin changes will also be required to create payment request and send uniqueId as part of referenceId or additional attribute that gateway provides, if retailers are using other gateway other than "Payware connect". Hardening workflow Handling Communication error There can be communication errors from the payment terminal device, the gateway or from the Manhattan Active solution (Payment Component) which need to be handled in our application.  When such a communication error occurs, the application will perform a get call to gateway or to the payment component 3 times to get the status. Please check below on the possible outcomes if all three attempts fail. MAO POS has recently developed an improved failure handling process that will result in fewer abandoned transactions and more flexible options for the user. Note: The improved Failure Handling is controlled by Change in Behavior "POS Payment Failure Handling". See the Behavior Change documentation. The new Failure Handling process will be enabled for any new customer environments created after Release 23.1. It will not be immediately enabled for existing customer environments.  Existing customers may enable the new process after Release 23.1 and should do so in testing environments. It will be automatically enabled for them by the end of 2023. The legacy process will be deprecated and no longer available as an option by 30-Dec 2023. Prior to Release 23.1- Legacy Comm failure handling Error from gateway - if get call = found, and update requestLogs as "Processed" and move forward to confirm the order or partial payment. Error from gateway - if get call = not found, go back to summary screen and update requestLogs as "Reconciled" so that they are not considered durng EOD Payment reconciliation. If the request had failed, this logic is appropriate. If the request had succeeded, this is a logical gap. Associate must request customer to pay again, however, the not found but 'reconciled' payment record may cause duplicate charges. Error from gateway - if get call receives communication error (no response). Request log is created with status CREATED. No payment transaction is created. Abort the Order transaction, return user to empty cart. At end of day, payment reconciliation process will query the gateway and cleanup the data by creating and canceling (if needed) a payment transaction for the one that couldn't be created at transaction time -other cleanup may occur if payment not found in gateway at all, etc. Legacy Workflow Following Release 23.1- Flexible Comm failure handling Error from gateway - if get call = found, and update requestLogs as "Processed" and move forward to confirm the order or partial payment, as appropriate. Error from gateway - if get call = not found, go back to summary screen.  With new functionality do NOT update requestLogs as "Reconciled". Since logs are left unreconciled ("Created") they will be cleaned up as part of EOD Payment reconciliation. Allow user to try same or alternate payment method again Error from gateway - if get call receives communication error (no response), the new flow is the same as "not found" above. Leave logs unreconciled Since logs are left unreconciled ("Created") they will be cleaned up as part of EOD Payment reconciliation. Allow user to try same or alternate payment method again Delay Receipt until Order Confirmation Order confirmation call happens after completing the payment, after which the users are allowed to navigate to the receipt screen. To ensure a smooth transaction process, the system prevents users from proceeding to the receipt screen unless/until the order is confirmed. In case of network issues or API failures, users will be provided with options to retry the transaction or start over. Order confirmation failure If an error occurs, the user will not be allowed to proceed to the receipt screen. Instead, an error pop-up will appear with two options: Retry or Start Over. Retry will attempt to confirm the order again by internally retrying the order confirmation up to three times. If the Retry attempt also fails, the user will be redirected back to the error pop-up, where they can either retry again or start over the transaction. If the order confirmation is successful during one of the retries, the user will be directed to the receipt screen. Start Over will cancel the transaction and reverse the payment and users will land in an empty cart. The associate should not hand over products to the customer until the order confirmation is successful. In case Scenario System Response Successful Order Confirmation status User proceeds to the receipt screen Failure to Order Confirmation call Error pop-up appears with Retry & Start Over options User selects Retry Order Save API is retried up to 3 times Retry fails 3 times Error pop-up reappears with Retry & Start Over options User selects Start Over Payment is reversed, and the user is taken to an empty cart. Asynchronous Order Confirmation To improve the checkout experience, the POS system now supports asynchronous order confirmation. This means that even if there is a small delay or technical issue in the background, the customer can still complete their checkout and receive a receipt without waiting. Previously, when an order’s payment was completed and the balance due became $0.00, the system had to confirm the order before showing the receipt. If there was any delay in the backend, it would block the UI and interrupt the user experience. Now, the system allows users to proceed directly to the receipt screen, even if the order confirmation in the backend is slightly delayed due to network or server issues. Whenever the order confirmation step fails for whatever reason, an entry is made into a staging table and the UI proceeds further to allow the user to print a receipt for the customer, so that the order can be completed, and the customer can be sent with the goods and the receipt. The orders that are pushed to the staging table are then picked up for confirmation asynchronously. If the order confirmation is successful in the async process, the order is removed from the staging table. If the order fails confirmation even in the async process, then the order remains in the staging table to provide visibility. There should also be order failed messages present which can be picked up for review to see why the confirmation failed and can be fixed. Reconciliation The end-of-day reconciliation process will pick up the order that was deferred for confirmation, if the confirmation was not successful during the async process. The reconciliation job will ignore any order that falls into the async confirmation process for 3 days. The expectation here is that the order will be either confirmed within three days or someone has already actioned on them based on the confirmation failure, either by looking at the staging table or the order failed messages. This feature is controlled by the Behavior Change timer, "POS - Asynchronous Order Confirmation". It will be released in production environments on August 15, 2026, but you can opt in earlier. Note: Re-printing receipts, post voids, and returns will not be allowed for these orders until the order is confirmed. Cart Refresh During Network Issues POS improves the user experience during payment failures by updating the UI with an error message and refreshing the order upon tapping the “Refresh button,” on the error pop-up and dynamically adjusting the UI based on the latest payment status—navigating to the receipt if complete(balance due=0) or reloading the payment page with accurate tenders if pending. Sale Flow: In case of a timeout or API error during payment, the user will see an error pop-up. The message in the pop-up will inform the users that there was an issue with the payment. When the user taps on the “Refresh Payment Status” button, the cart will refresh, and the payment page will reload with the latest order information. If the refreshed order shows no balance due, the user will be automatically navigated to the receipt screen. If there is still a balance due, the screen will display the available payment options along with an updated applied tenders section that reflects any previously applied tenders. In case the order refresh also fails, the users will remain on the order summary screen. Note: Sale Flow currently only supports credit card failures. Refund Flow: In case of a timeout or API error during a refund, the user will see an error pop-up. The message in the pop-up will inform the users that there was an issue with the refund. When the user taps on the “Refresh Refund Status” button, the cart will refresh, and the payment page will reload with the latest order information. If the refreshed order shows no balance due, the user will automatically navigate to the receipt screen. If there is still a balance due, the screen will display the available refund options along with an updated applied tenders section that reflects any previously applied tenders. Note: Cart refresh for the refund flow supports all payment types for automatic refunds. However, for override refunds, custom tenders and paper tenders with pop-cash drawer=true are currently not supported. Last Trans Functionality Last Transaction - Immediate Retry Whenever a payment transaction is initiated from the POS application and the request is sent to the terminal, and if there is a network issue or delay in receiving a response from the terminal back to the application, the plugin now initiates a last transaction call to the terminal. The last transaction call retrieves the last transaction that was executed on the terminal. So, in the case of a transaction that was fired to the terminal and the POS application did not get a response or missed the response due to network issues, if the last transaction call is fired successfully, then the POS application can compare the response of the last transaction against the transaction that the application did not get a response for. If the last transaction matches with the open transaction that the POS application is waiting for, then the application will immediately apply the response from the last transaction to the open transaction and mark it successful. This approach reduces the occurrences of abandoning payment transactions which are impacted by network issues or temporary loss of connectivity. For example, the store associate is checking out a customer order for $100, the associate chooses the card payment option and the application makes a request to the payment terminal to capture $100. The terminal lights up, and the customer is asked to engage with the terminal to complete the transaction. The customer will use their card on the terminal to complete the payment and the payment may show as captured on the terminal. It is possible that the application has lost connectivity with the terminal or there is a spotty network situation and the response from the terminal about the captured transaction does not reach the application. When the application detects that there is no response from the terminal for the sale transaction that was initiated, the application will now fire a last transaction call to the terminal. The last transaction call can also fail to get a response if the network error persists. It is also possible for the last transaction call to receive the successful capture response for the $100. The response of the last transaction is processed and if there was no response, a new last transaction call is issued. If the last transaction response was for the $100 sale that was executed now, then the transaction is updated and the user is automatically navigated to the next screen in the flow. The other possible scenario could be that the user never swiped the card or the transaction was not processed in the terminal or gateway successfully. In this case also, if the application fires the last transaction, we may still get no response if the network error persists, or it is also possible for the last transaction to receive a transaction response that was executed earlier. If the response is for a previous transaction, then the last transaction call is stopped and a network error is shown to the user. The last transaction response is matched to an open transaction on the application using the following three fields: Amount Invoice number Payment type The last transaction call is fired every second for 10 times and if the last transaction call also fails, then the application returns a communication error. Last Transaction - On Demand As explained above, it is possible that all the last transaction calls also fails if the network issue is persistent and the application is not able to reach the terminal. In the event that all the last transaction calls also fail, the application eventually throws the network error back to the user. Now the associate is back in the checkout screen and the associate can inform the customer that the payment did not get updated properly. The associate can retry the same payment method by selecting the same payment method in the checkout screen. When this happens, the application has a record that the previous transaction that was executed for this payment method was inconclusive and the status is not updated. So, instead of issuing a new capture request to the terminal, the application now fires another on-demand last transaction call. The on-demand last transaction call is the same as the immediate last transaction call. The response of this call is if it gets the capture response of the open transaction, then the transaction is updated as a success and the associate is navigated to the next screen in the application. This eliminates the need for the customer to interact with the terminal again and also collect the money again. For example, the store associate is checking out a customer order for $100, the associate chooses the card payment option and the application makes a request to the payment terminal to capture $100. The terminal lights up, and the customer is asked to engage with the terminal to complete the transaction. The customer will use their card on the terminal to complete the payment and the payment may show as captured on the terminal. It is possible that the application has lost connectivity with the terminal or there is a spotty network situation and the response from the terminal about the captured transaction does not reach the application. When the application detects that there is no response from the terminal for the sale transaction that was initiated, the application will now fire a last transaction call to the terminal. The last transaction call can also fail to get a response if the network error persists. The last transaction call retries are exhausted, and the network error is displayed to the user. The associate is now taken back to the checkout screen. The associate informs the customer of the problem and initiates the payment request to the terminal again, but now the application has a record of the previous transaction in open status. The application, instead of firing the capture request for payment, fires the last transaction call on demand. If the last transaction response contains the successful transaction response for the open transaction, then the transaction is updated as a success in the POS application and the associate is navigated to the next screen. If the last transaction call fails or gets a response that doesn't match the previous open transaction, then the application fires the capture request to the terminal and the customers are required to swipe again. The on-demand last transaction eliminates the need for the customer to re-swipe the card, and it also makes the purchase experience better on top of reducing the impact of issues due to communication failures during checkout. Note: Last transaction is currently only supported for Payware Payment Reconciliation Payment reconciliation is a process of correcting the erroneous payment transaction with the payment gateway, the error can be when payware or payment component response resulted in communication error and where payment has gone through the point gateway but not saved on our payment component because of error in response from payware. The requestLogs data for such payment transaction will be in "created" or "processed" status, Such data is picked to revisit these transactions on gateway by performing a transsearch api call using the invoice # and check if these transaction made to payment, if not then capture payment component for reversal with point gateway. Fetch gateway token for SAF transactions: The first step in Payment reconciliation is to fetch gateway if there were any store and forward transaction processed during the day. Please check below steps. Find all SAF transactions without gateway token. Check the reconciliation retry limit (pos general config > reconciliationRetryLimit) , if the saf transaction has not reached the retry limit (everify the latest limit on reconciliationLogs) then pick this transaction for SAF reconciliation. Place a transsearch api call using invoice# and on successful response from the gateway, save the response of gateway token on requestLogs and payment component. Update reconciliationlogs for the SAF reconciliation attempt. If transsearch api call using invoice# and on unsuccessful then update reconciliationLog with a link to parent requestLog ID as [reconciliationType = SAF, numberOfRetry = runningNumber, retryLimit= {fromConfig}, reconciliationStatus =Failed, requestData = {sent to gateway}, responseData = {received from gateway}] Note: Milestone job (which run every 2 hours) will not picked abandoned orders in readyForTender = TRUE status. Work Flow of payment reconciliation Reconciliation process is called within the store close operations and has the follow steps: Perform SAF reconciliation as explained above for below data on requestLogs data and reconciliation retry limit is not reached. SAF# or Voice Auth Present + ( requestLog status =Completed ) + Payment have this uniqued Id i.e. Processed. SAF# or Voice Auth Present + ( requestLog status =Processed) + Payment have this uniqued Id i.e. Processed. SAF# or Voice Auth Present + ( requestLog status =Created) + Payment does not have this uniqued Id i.e. Created. Perform the actual reconciliation for all below kind (reconciliation process is explained below). requestLogs status = Processed, PTT=True, 3rd Party False + Payment processed. requestLogs status = Processed, PTT=False, 3rd party False +Payment processed. (Should be taken care in user exit) requestLog status = Processed + PTT=False, 3rd party TRUE +Payment processed. (Should be taken care in user exit) requestLog status = Created + PTT=True + Payment NOT processed. Reconciliation Process Outline Validate if the requestLog status = processed or created. Then check the PTT flag, if its true Then, check 3rd party = false, if its false, Then go to payment component and check if the payment transaction with this unique Id exists. If exists then do below: Validate Payment transaction status = Closed or Open If Payment transaction status = Open , and mark requestLog status = reconciled. And If not already present update Payment transaction with the CTROUTD, TROUTD and other payment details from the gateway. If Payment transaction status = Closed, further mark requestLog status = reconciled Then update reconciliationLog as Passed with other details. If does not existing on payment component then perform transsearch api call on gateway using the invoice # Validate the transsearch response with the payment component for this invoice and find the delta in payment component. For all the delta, create payment transaction in open status and mark requestLog status = reconciled Update reconciliationLog as passed with other details. Services The following APIs are related to payment. Refer to the API documentation for additional details on each service. Service Component Group Service Endpoint Close Invoice Order Order Services /order/api/order/order/orderId/{orderId}/invoiceProcessedAmount Get Order Order Order Services /order/api/order/order Get Order Value Order Order Services /order/api/order/order/getOrderValue Get Payment Header Payment PaymentHeader Services /payment/api/payment/paymentHeader Get Payment Status Payment PaymentStatus Services /payment/api/payment/paymentStatus Save Payment Header Payment PaymentHeader Services /payment/api/payment/paymentHeader/save Save Payment Request Payment PaymentRequest Services /payment/api/payment/paymentRequest/save Total Payment Summary Payment payment-summary-controller /payment/api/payment/paymentSummary/total/orderId/{orderId} Exchange Tender Transaction posservice Order Service POST /api/posservice/order/addAttributeToOrder Transaction void posService POS Service POST /api/posservice/override/command/transVoid Balance Enquiry posservice Payment Transaction Service POST /api/posservice/payment/addGiftItemBalance Add Tender posservice Payment Header Service POST /api/posservice/payment/addTender Update Ready for Tender posservice Payment Service POST /api/posservice/order/updateReadyForTender Add Refund Tender posservice Payment Header Service POST /api/posservice/order/addRefundTender Search Customer Search Search Service GET /api/search/customer Activate Customer Search Search Service GET /api/search/customer/customerId Save requestLogs posservice Request Logs Service POST /api/posservice/requestLogs/save Save reconcileLog posservice Reconciliation Logs Service POST /api/posservice/reconcileLog/save SAF Payment Reconciliation posservice Payment Reconciliation Service POST /api/backoffice/backofficeTransaction/SAFTransaction/updateTokenInfo Payment Reconciliation posservice Payment Reconciliation Service POST /api/backoffice/backofficeTransaction/paymentReconciliation Async order confirmation order Staging for async order confirmation GET /api/order/orderConfirmRequest/orderId/{{orderId}}