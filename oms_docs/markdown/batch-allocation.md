# Allocation

**Permalink:** batch-allocation
**Path:** Manhattan Active® Omni/Order Management/Process & Configuration Guides/Order Processing/Order Fulfillment/Order Allocation/Batch/Allocation
**Content Length:** 38,727 characters
**Scraped:** 2025-08-09T21:57:12.316519

---

Home ››Manhattan Active® Omni››Order Management››Process & Configuration Guides››Order Processing››Order Fulfillment››Order Allocation››Batch ››Allocation Allocation I Next OverviewHow Batch Allocation WorksBatch Allocate PipelineForm Batches of AllocationEvaluate Fulfillment Optimization ConfigurationForm Promising RequestPromising ResponseConfigurationConfiguring Batch AllocationConfiguring the Batch Allocation JobConfiguring the Batch Job Completion EventImplementation FlavorsTroubleshooting Orders in backorder status are not getting allocatedRelated Articles Overview When the fulfillment needs to be prioritized across the orders, typically the inventory allocation process is run in a batch mode rather than the first in first out manner. Accumulating the orders to allocate, provides an opportunity to prioritize the orders when supply and capacity are constrained. This batch process can be used for any types of orders including store replenishment, business to business and customer orders. Batch vs. Immediate mode (allocation and release) can be enabled by setting up rules, rule condition and pipeline. Rules can be configured to use certain rule conditions and upon successful evaluation, rules can be configured to perform certain rule action (AKA Pipeline). Rule condition can be defined with either Order or Order line attributes and matching value. Rule action is mapped to Pipeline ID. Refer How to set up Batch Allocation for more details. Batch allocation can be scheduled to run at a specific time interval taking query as an input (based on order and order line attributes) to filter orders to allocate. Refer How to set up Job details for more details. How Batch Allocation Works Refer to How Allocation works for details on Allocation rules. Batch Allocate Pipeline When an Order is created, rules are evaluated based on the matching rule conditions and corresponding rule action (pipeline) is invoked. Immediate allocation and release can be invoked by setting up "AllocateOrder" and "ReleaseOrder" service as part of pipeline (state transition). This is enabled by default. When an order is created, system tries for immediate allocation and release (provided there is a matching fulfillment optimization and release configuration). Batch allocation can be invoked by setting up "BatchAllocate" service as part of the pipeline. When an order is created, and is picked by pipeline with "BatchAllocate" service then the Order remains in open status (immediate allocation is not invoked). These orders can be picked up by Batch Allocate job scheduler. Based on the business requirements, Pipeline can be configured to perform the below operations. Refer How to set up Batch Allocation for more details. Form Batches of Allocation When Batch Allocation scheduler runs (Refer How to set up Job details for more details), the system consolidates all Orders with overlapping SKUs in one batch to optimize batch allocation. Within a batch, orders are submitted for allocation sequentially in order of their effective rank (which is calculated during prioritization). Since the reservation is by Order and not by Order lines, entire order is submitted for allocation. Order is submitted for allocation based on the minimum effective rank of its Order lines. Example 1 -  There are four Orders and effective rank is same for all the line(s) in an Order. Batch 1 is formed with Order 1 and Order 2 as there is an overlapping SKU (SKU B). Batch 2 is formed with Order 3 and Order 4 as there is an overlapping SKU (SKU D). Within Batch 1 - Order 2 is submitted before Order 1 as Order 2 rank (minimum rank for all its order lines is 1) is higher than Order 1 (minimum rank for all its order lines is 2). In Batch 2 - Order 4 is submitted for allocation before Order 3. Example 2 - There are four Orders and effective rank is different for the line(s) in an Order. Since reservation is by Order - even though Order 1 - SKU B is ranked higher than Order 2 - SKU B, Order 2 is sent for allocation before Order 1 as Order 2 rank (minimum rank for all its order lines is 1) is higher than Order 1 (minimum rank for all its order lines is 2). This can lead to lower ranked order line(s) consuming the supply before higher ranked order line(s). Orders across batches are tried for Allocation parallelly. Orders within Batch are tried for Allocation sequentially based on the effective rank and sent to promising one at a time. In the above example - Batch 1 Orders and Batch 2 Orders can be submitted in parallel to allocation as there are no overlapping Items. Since Batches runs in parallel, there is a chance of capacity being consumed before allocating the higher ranked order. In the above example, consider location capacity is only two Orders. Since Batch 1 and Batch 2 run in parallel, Batch 2 Orders can get allocated first followed by Batch 1 thereby consuming the entire capacity (even though the rank of Orders in Batch 2 is lower than the Orders in Batch 1). Since typically batch allocation is used for retail Orders (which gets fulfilled from DC location), Capacity may not play an active role. If inventory quantities are constrained during batch allocation, the orders are fulfilled based on the effective rank. For example, there are 10 units of Item A, and there are two orders which need Item A. The first order requests 6 units, and the second requests 8 units. The total requested quantity is 14 units, so there are not enough units to fulfill both orders completely. In the regular order flow, the first order created would be completely fulfilled, and the second order would be partially fulfilled. If run in batch mode, the order with the highest effective rank is fulfilled first and then the rest in the order of the rank. Also, system prioritizes the supply based on the rank (Supply type) and ETA (for future supplies) while allocating an Order. Example: Consider the following supply type and supply set up. System is configured to give priority to On Hand available bucket followed by On Hand available soon, In Transit and then On Order. Within In Transit or On Order supplies - system gives priority to the supply based on the ETA. In this example, system gives priority to ASN 1 before ASN 2 as ASN 1 ETA is earlier than ASN 2. Evaluate Fulfillment Optimization Configuration Refer to How Allocation works for more details Form Promising Request Refer to How Allocation works for more details Promising Response Refer to How Allocation works for more details Configuration Configuring Batch Allocation By default, Immediate allocation is enabled. Refer to the sample configurations required to set up Batch Allocation and Release Rule Condition: Rule condition needs to be added to include only Retail Orders. { "RuleConditionId": "RULE_CONDITION_REPLENISHMENT_ORDER", "ConditionValue": "{\"expression\":{\"lhs\":{\"operandType\":\"attribute\",\"attribute\":\"orderLine.parentOrder.docType.docTypeId\"},\"rhs\":{\"operandType\":\"constant\",\"value\":\"RetailOrder\"},\"operator\":\"=\"}}" } Pipeline: Custom pipeline needs to be created if batch mode needs to be enabled for Replenishment Orders. Instead of AllocateOrder and ReleaseOrder service, batchAllocate and batchRelease should be invoked. { "ProcessTypeId": "ORDER_EXECUTION", "PipelineId": "OrdersWithbatchAllocationandRelease", "Description": "Orders with Batch Allocate and Release", "PickupService": [ { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "batchAllocate" }, { "FromStatus": "1500", "ComponentId": "Order", "ServiceId": "batchAllocate" }, { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "allocateOrder" }, { "FromStatus": "1500", "ComponentId": "Order", "ServiceId": "allocateOrder" }, { "FromStatus": "2000", "ComponentId": "Order", "ServiceId": "batchRelease" }, { "FromStatus": "2000", "ComponentId": "Order", "ServiceId": "releaseOrder" } ], "DropStatusDetermination": [ { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "batchAllocate", "IntendedDropStatus": "1500", "Sequence": 1, "ConditionText": null, "DropStatus": "1500" }, { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "batchAllocate", "IntendedDropStatus": "2000", "Sequence": 1, "ConditionText": null, "DropStatus": "2000" }, { "FromStatus": "1500", "ComponentId": "Order", "ServiceId": "batchAllocate", "IntendedDropStatus": "2000", "Sequence": 1, "ConditionText": null, "DropStatus": "2000" }, { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "allocateOrder", "IntendedDropStatus": "1500", "Sequence": 1, "ConditionText": null, "DropStatus": "1500" }, { "FromStatus": "1000", "ComponentId": "Order", "ServiceId": "allocateOrder", "IntendedDropStatus": "2000", "Sequence": 1, "ConditionText": null, "DropStatus": "2000" }, { "FromStatus": "1500", "ComponentId": "Order", "ServiceId": "allocateOrder", "IntendedDropStatus": "2000", "Sequence": 1, "ConditionText": null, "DropStatus": "2000" }, { "FromStatus": "2000", "ComponentId": "Order", "ServiceId": "batchRelease", "IntendedDropStatus": "3000", "Sequence": 1, "ConditionText": null, "DropStatus": "3000" }, { "FromStatus": "2000", "ComponentId": "Order", "ServiceId": "releaseOrder", "IntendedDropStatus": "3000", "Sequence": 1, "ConditionText": null, "DropStatus": "3000" } ] } Rule Action: { "RuleActionId": "ORDER_BATCH_MODE", "ActionDescription": "Order Batch Pipeline Action", "ActionValue": "OrdersWithbatchAllocationandRelease" } Rules: { "RuleId": "Retail", "RuleGroupId": "", "RuleDescription": "Replenishment Order Rule", "Component": "Order", "RuleStatus": "active", "RuleVersion": "1", "Salience": "5", "DisplaySequence": "1", "ActivationDate": null, "ExpirationDate": null, "RuleConditionId": "RULE_CONDITION_REPLENISHMENT_ORDER", "RuleActionId": "ORDER_BATCH_MODE" } Configuring the Batch Allocation Job Batch allocation can be scheduled to run at a specific time interval and query can be defined (based on order and order line attributes) to filter orders to allocate. All orders matching the query filter is selected for Batch allocation. Any Orders with max fulfillment status greater than 1500 (Allocated and above) is not considered for Batch allocation. To schedule a batch allocation job, post the below message to the endpoint "/api/batch/jobSchedule". The JobScheduleId must be updated as the identifier for every job. Batch allocation job schedule is set up with jobTypeId "reallocationJob" and can take two job parameters. Parameter 1: Query can take Order and Order line attributes. Note that if status is not provided in the query then system considers only open and back ordered quantities for batch allocation. Sample Queries Level Attribute Sample Query Order Doc Type { "InputKey": "Query", "InputValue": "((DocType.DocTypeId = 'RetailOrder'))" } Order Order Type { "InputKey": "Query", "InputValue": "((OrderType.OrderTypeId = 'ReplenishmentOrder'))" } Order Line Ship to Location { "InputKey": "Query", "InputValue": "(OrderLine.ShipToLocationId IN ('Store1', 'Store2')" } Both Doc Type and Ship to Location { "InputKey": "Query", "InputValue": "((DocType.DocTypeId = 'RetailOrder') AND OrderLine.ShipToLocationId IN ('Store1', 'Store2'))" } Parameter 2: Reallocate flag is set to False as system needs to perform only batch allocation and no reallocation { "JobScheduleId": "BatchAllocate-RetailOrders", "JobTypeId": "reallocationJob", "CronExpression": "0 0 0/2 1/1 * ? *", "StartDelay": 1000, "RepeatInterval": 20000, "TriggerKey": "BatchAllocate-RetailOrders", "JobParameters": [ { "InputKey": "Query", "InputValue": "(DocType.DocTypeId = 'RetailOrder')" }, { "InputKey": "Reallocate", "InputValue": "false" } ] } Configuring the Batch Job Completion Event There are various features which runs in batch mode - batch allocation/reallocation, batch release, reapportionment. But there is no systematic way to trigger a job on completion of another one. User needs to define job schedules in such a way that the previous job is finished well in time before the next job is scheduled to run. For instance: when reapportionment is completed, there is no call back for a user to take a particular action such as “trigger any other job” or raise any custom event. The Retailer who needs to trigger "Job A" after "Job B" finishes can leverage this feature. For instance: In order to trigger subsequent jobs, such as release to the WMS, to run once the reallocation or reapportionment process is complete. As part of this feature, there will be an event invoked on the successful completion of reapportionment & batch allocation/reallocation jobs. Event names will be different for the different job types and payload will have key details such as Job Type Id, Job Run Id, Status, total number of records, ANF Config Id, etc. Any user action such as triggering a custom job or triggering another batch job can be tied to this event by customization. For Batch Allocation or Reallocation - Order:Order:Event:OnReallocationJobCompletion { "Status": "completed", "ReferenceField1": null, "JobTypeId": "reallocationJob", "ReferenceField2": null, "ReferenceField3": null, "ReferenceField4": null, "JobRunId": "807453407", "TotalSuccessfulRecords": 4, "TotalExpectedRecords": 4, "JobScheduleId": "reallocationJob-Test1" } For Reapportionment - Order:Order:Event:OnReapportionmentJobCompletion { "Status": "completed", "ReferenceField1": "PCN1595909964602", "JobTypeId": "reapportionmentJob", "ReferenceField2": null, "ReferenceField3": null, "ReferenceField4": null, "JobRunId": "116044bd-7850-4a86-ab9b-d2d23ce282ed", "TotalSuccessfulRecords": 4, "TotalExpectedRecords": 4, "JobScheduleId": "reapportionmentJob-Test2" } Note* "TotalExpectedRecords" is total number of orders for which job is run "TotalSuccessfulRecords" is total number of orders for which allocation is successfully updated (backorder/allocated) "ReferenceField1" is populated with Fulfullment Optimization Configuration Id (only for Reapportionment Job) Every single run will raise an event and payload will be dropped to queue ( if configured ) Exception Handling while raising event In case of exceptions such as allocation update failure for few orders, the base will raise the event with Status="Failed" with details in TotalExpectedRecords, TotalSuccessfulRecords fields. Exception is raised when orders for a job run have failed allocation update and last updated order have elapsed more than 10 mins ( Timeout Window ). In such case, status will be "Failed" and TotalSuccessfulRecords will be less than TotalExpectedRecords. In case there is no eligible orders for reapportionment/reallocation run, event will still be raised with TotalExpectedRecords/TotalSuccessfulRecords as Zero. Configuration To enable this feature, the user needs to explicitly define the job schedule for "statusMonitorJob" with a frequency of 5 minutes (base recommendation). { "JobScheduleId": "Job1", "JobTypeId": "statusMonitorJob", "CronExpression": "0 0/5 * 1/1 * ? *", "TriggerKey": "statusMonitorJobTrigger", "IsDisabled": false, "Actions": { "JobParameters": "RESET" } } Note* MaxWaitTime ( Timeout Window ) is an optional job parameter for reapportionment or batch allocation/reallocation batch job schedules. Default value is 10 mins. When orders for a job run have failed allocation update and the last updated order has elapsed more than X mins ( where X is MaxWaitTime ), the base will raise the event with Status="Failed". Default behaviour for reapportionment, batch allocation/reallocation will be to track status by JobStatus & JobStatusDetail entities and raise an event on Success/Failure. In case, the user wants to disable it explicitly then "IsJobStatusMonitor" = False should be defined as Job Parameters for respective batch job schedules. Purge Criteria Purge Mechanism is enabled for JobStatus & JobStatusDetail entities. These are used to track orders during batch job processing. Records will be purged after 30 days in both the entities irrespective of status. It can be overridden by property file in KV store: entity.transaction.data.retention.duration = JobStatus::60,JobStatusDetail::60 Nightly scheduler which is default enabled from the base will purge the records with purgeDate < currentDate. Manual Purge (Only SystemAdmin) to purge all entities if purge date < currentDate - POST API: url/order/api/fwEntityPurge/entities/purge with input as { "ProcessId": "111111" } Illustration # : Trigger batch release, once reapportionment process is complete This can be achieved by following below steps ( customization ) Step 1: Configure extPointToMsgType for reapportionment event POST /order/api/ServiceDefinition/extPointToMessageType/save { "ExtensionPointId": "Order:Order:Event:OnReapportionmentJobCompletion", "MessageType": "{{customMsgType}}" } Step 2: Read message from CustomQueue, if status=”completed” then make a get call to fetch list of orders for the JobRunId present in event payload GET /order/api/order/jobStatusDetail?JobRunId='<Value>' Step 3: Call Rest API for the list of orders to trigger release POST /order/api/order/order/releaseOrders { "OrderIds" : [ "Order1", "Order2", "Order3"] } Implementation Flavors N/A Troubleshooting Orders in backorder status are not getting allocated Issue: When orders are processed in Manhattan Active® Omni, they are backordered due to inventory or capacity issues. However, when capacity is released, these orders remain in backorder and are only allocated when force allocated. Solution: When capacity increases, the inventory component does not trigger an event to reallocate the order. You can schedule a reallocation job every 3 to 4 hours, or at intervals suited to your business needs. Related Articles Re-allocation