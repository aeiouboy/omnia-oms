# Creating and Updating Order

**Permalink:** creating-and-updating-order
**Path:** Manhattan Active® Omni/Order Management/Process & Configuration Guides/Order Orchestration/Creating and Updating Order
**Content Length:** 85,675 characters
**Scraped:** 2025-08-09T21:56:23.561068

---

Home ››Manhattan Active® Omni››Order Management››Process & Configuration Guides››Order Orchestration ››Creating and Updating Order Creating and Updating Order Previous I Next OverviewOrder PipelineOrder StatusOrder PricingOrder UpdateOrder ConfirmationOrder SearchConfigurationsHow to Set Up Order Type ConfigurationFactors Affecting Order ConfigurationHow to Set up General ConfigurationsHow to Configure Modification RulesExtended Order Status ConfigurationImplementation FlavorsIntegration approach for Host sending 'full updates'How to maintain the same FulfillmentGroupId on addition of new line when all the lines are shipping to the same addressHow to change the order status descriptionTroubleshootingInvoiceLineTaxDetail missing Shipping Charge from the OrderLineTaxDetailIs it possible to update order through bulk import API Overview A common order interface is used for creating and updating orders. You can send the partial order updates, and the Order component processes the updated attributes without modifying the other attributes of the order. A full update can also be sent. The Order component identifies and updates only those attributes which are updated. For example: If only the customer ID is changed as part of an order update, then the Order component saves the new customer ID and retrieves the first name, last name, email, and phone for the updated customer. If an appeasement is applied as part of an order update, then the Order component applies the discount to the order, recalculates tax, and updates the order totals. The Order schema comprises two parent parts: an order header and order lines. The order header includes customer and order capture information, and the header can optionally include order-level holds, charges, taxes, and discounts. Order lines include item-specific information such as quantity, shipping method, and address. As well as optional information, such as item specific information from item master, line-level holds, charges, taxes, and discounts. Order Line Attributes Refer to the following sections to understand the attributes associated with an order line. Attributes Description Item Attributes The list of item attributes that are copied from item master to order line is: itemStyle itemSeason itemDescription itemShortDescription smallImageURI itemDepartmentNumber itemNumber itemDepartmentName itemBarcode itemColorDescription itemSize itemBrand Delivery Method Each order line has a delivery method that identifies the way a product is delivered to a customer. In case of returns, it indicates the method by which the retailer receives the product from the customer. The application supports the following delivery methods: Delivery Method Description Store Sale Delivery method in which a customer purchases items in a store in a traditional point of sale (POS) transaction.The items can either be added to the cart by scanning the barcode or through RFID. Incase of RFID enablement, each unit EPC ID will be passed and persisted in order line fulfillment detail. Ship to Address Delivery method in which a seller ships the inventory directly to the customer. For Ship to address, order lines go through promising to identify a location that can fulfill the ordered item(s) using the input shipping method or carrier/service level combination. Ship to Store Delivery method in which a seller ships the inventory to a store for customer pick up. For ship to store, the inventory can be allocated from any eligible locations (distribution centers (DCs) and other stores) that ships to the store for customer pick up. Pickup at Store Delivery method in which a customer orders items and picks them up from a store. In case of pickup at store, the inventory must be present in the pickup store. Email This delivery method is used for digital goods like music, software, and e-gift cards that do not follow the traditional physical fulfillment life cycle, since they are not stocked at a facility. These items are “released” to an external system which emails the digital goods to the customer and then updates the order component once the fulfillment has occurred. Store Return Delivery method in which a customer returns items to a store in a traditional point of sale (POS) return transaction. Ship to Return Center Delivery method in which a customer returns items by shipping them to the return center of the seller(for example, DC). An order can contain both sale and return order lines within a single order. The fulfillment process of each line depends on its delivery method, so each order line is processed individually. For example, an order having lines with one of the following combinations of delivery methods are possible: “Ship to Address” and “Store Sale” “Ship to Store” and “Ship to Return Center” “Store Sale”, “Store Return” and “Pickup at Store” "Ship to Return Center" (a "pure return" order) Delivery Method Sub Types In addition to the Delivery Method, each order line can have a Delivery Method Sub Type which identifies various operating procedure/s supported for delivering products to a customer for a given delivery method. For example, a Curbside Delivery Method Sub Type supported for Pickup At Store Delivery Method is where customers can buy online, drive to the store, and remain in their car while a store associate delivers the items to their trunk in addition to the standard In Store pickup, where the customers come inside the store to pick up the items. The Delivery Method Sub Type for an order line can be left black or populated with only one Delivery Method Sub Type. The Delivery Method Sub Types supported for various Delivery Methods is listed below: Delivery Method Delivery Method Sub Type Description Pickup at Store Curbside Pickup Customers can buy online, drive to the store, and remain in their car while a store associate delivers the items to their trunk. Pickup at Store Instore Pickup Customers can buy online, come inside the store and the store associate personally delivers the items to the customer. Note: If Delivery Method Sub Type is populated it is published in the Release Outbound in Release Line, and Release is grouped for each Delivery Method Sub Type in addition to other attributes used for Release grouping. Order Line Quantity Each order line has a quantity attribute that specifies the ordered quantity. Orders can be created or imported with both integer and decimal quantities. For decimal quantities, the system supports order creation, allocation, promising fulfillment, returns and exchanges. Feature Scope for decimal quantities: Creation or modification of customer orders, as well as return and exchange orders, is not supported through the CallCenter UI. Fulfillment using Manhattan Active SOF. Pricing, Charges, Taxes, Invoicing & Payment. Note: Orders for items can be placed in decimal quantity up to four decimal places. Items like cables, hose, wire, pipes, etc where customers prefer to place order in decimal quantity. The scope of decimals extends to inventory management, promise, allocation, fulfillment (pick/ship/short/ order events) and returns and exchanges. The order summary for decimal quantity orders can be viewed in the call center with donuts and quantity values displayed in decimals. Round off: When users try to place orders for quantity with more than four decimal places then system rounds off the value upto 4 decimal places. For example if user places an order for a cable of 5.12367 meters then the quantity is rounded of to 5.1237 meters. Out of scope: Currently supporting for order pricing/invoicing/SOF/CS, EOM are out of scope. Order Line Fulfillment Group Id An attribute called Fulfillment Group Id is available in the order line, charge detail, and tax detail entities to provide the ability to relate charges and taxes to a group of order lines. Additionally, fulfillment groups are used for items which need to be grouped for shipping, wherein the retailer wants the items shipped in a single package. A different type of fulfillment group called Release Group Id is when items are grouped for delivery, where the items can ship from multiple DCs/fulfillment centers, but will get delivered together by the carrier. Refer here for more details on Release constraint. Every time an order is created, Fulfillment Group Id is determined on each order line. The attributes used for Fulfillment Group Id calculation are Delivery Method, Shipping Method, Shipping Address in case of Ship To Address, Ship To Location Id in case of Pick Up At Store or Ship To Store, Order Line Additional Email in the case of Digital Goods. Note: If an order line email is not provided for a Digital Goods item, customer email on order will be used for fulfilling the digital items. However, the calculation of Fulfillment Group Id will not consider customer email. The fulfillment group Id is re-calculated if any of the above attributes is updated post order creation. Note: If there is a fulfillment group Id already populated during order creation, then the order component will not reset this. But subsequent updates to the order, like address, would re-calculate the fulfillment group Id. Example of FulfillmentGroupId Creation Order Line Id Address Id Shipping Method Id Delivery Method Id Ship To Location Id Order Line Email Fulfillment Group Id 1 Canada Next day Air Ship to address NA NA 11111 2 Canada NA Pick up at store NA NA 22222 3 Canada Next day Air Ship to address NA NA 11111 4 US Ground Ship to address NA NA 33333 5 Canada Next day Air Ship to store Store Atlanta NA 44444 6 NA NA Digital Goods NA alice@gmail.com 55555 7 NA NA Digital Goods NA alice@gmail.com 55555 8 NA NA Digital Goods NA alice.123@gmail.com 66666 9 NA NA Digital Goods NA alice.234@gmail.com 77777 10 NA NA Digital Goods NA Not Provided 88888 11 NA NA Digital Goods NA Not Provided 88888 Base fulfilment group logic does not consider into account item attributes. If there is a need to split the fulfillment grouping based on more order line or item attributes, then  use this UE Order:OrderLine:UserExit:OverrideFulfillmentGroupId to enforce the project's required grouping. Order Line Limit The orders that go through selling services such as pricing, promotion, tax, and payment or uses Customer service UI are deemed to be B2C/Customer Order. B2C orders support up to 250 lines. The system identifies them with a Doc Type as "CustomerOrder". The system also supports 250 shipments and invoices. The rest are categorized as B2B/Retail Replenishment Order and supports up to 5000 lines. They are identified with a Doc Type as "RetailOrder". Orders created using the POS application support up to 120 lines. The system identified them with an Order Type = "mPOS order". Because of the nature of retail orders and the retail supply chain in general, they also require a "Ship From Location" to be populated at the line level. Orders with Doc type as "RetailOrder" allocation are only supported when ShipFromLocationId is passed in the Order/Order line. Refer here for more details on Retail Orders and Large Orders. Note: For Get Order/Publish Order, use custom templates with only the required fields in the template to avoid timeout exceptions due to very large number of order lines, allocations, release, fulfillment details, and so on in the order. Order Pipeline A pipeline is used to define the state transition for orders. The pipeline defines the series of states through which a unit travels from order capture until fulfillment. A pipeline consists of a set of services and statuses, where each service moves order from current status to next status. For example, the Allocate service moves quantity from Open status to Allocated status. Each order lines may have a different life cycle based on the delivery method or other line attributes, so a pipeline determination rule is used to select a pipeline for an order line. When an order line is created, a pipeline is identified, and the pipeline ID is stamped on the order line. This pipeline is used for the remaining life cycle of the order line unless it needs to be re-evaluated. Default pipelines are provided based on the delivery method. The pipeline for "Ship to Address", "Ship to Store", and "Pickup At Store" order lines are as follows: The pipeline for order lines with delivery method "Store Sale", which is a traditional point of sale transaction is as follows : Digital goods have a separate pipeline from the physically-fulfilled goods, since there is no requirement to track or allocate inventory, and statuses like picked and packed that are required for physically-fulfilled goods are not relevant. The pipeline for order lines with delivery method "Email" is as follows: The pipeline for order lines with delivery method "Store Return" is as follows: The pipeline for order lines with delivery method "Ship to Return Center" is as follows: The pipeline for order lines with delivery method "Ship to Return Center" with Carrier Scanned status is as follows: API for incorporating Pipe Line changes for PipeLineId: SHIP_TO_RETURN_CENTER_EXECUTION with Carrier Scanned status: Sample API with Carrier Scanned StatusPOST {{url}}/order/api/ServiceDefinition/pipeline/save { "PickupService": [ { "FromStatus": "11000", "ComponentId": "Order", "ServiceId": "carrierScanReturn" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "approveReturn" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "processReturn" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "receiveReturn" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "verifyReturn" } ], "PipelineId": "SHIP_TO_RETURN_CENTER_EXECUTION", "ProcessTypeId": "ORDER_EXECUTION", "DropStatusDetermination": [ { "FromStatus": "11000", "ComponentId": "Order", "ServiceId": "carrierScanReturn", "IntendedDropStatus": "14000", "Sequence": 1, "ConditionText": "", "DropStatus": "14000" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "approveReturn", "IntendedDropStatus": "18000", "Sequence": 1, "DropStatus": "18000" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "receiveReturn", "IntendedDropStatus": "15000", "Sequence": 1, "DropStatus": "15000" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "verifyReturn", "IntendedDropStatus": "18000", "Sequence": 1, "DropStatus": "18000" }, { "FromStatus": "14000", "ComponentId": "Order", "ServiceId": "processReturn", "IntendedDropStatus": "18000", "Sequence": 1, "DropStatus": "18000" } ] } Each service in the pipeline has a pickup status and drop status which define the eligible quantity that can enter the service and the resultant status after the service is executed. For example, the Release service picks up from Allocated and drops in Released status. Quantities in Backordered status are ineligible to be picked up by the Release service. The pickup and drop status of the Allocate service are illustrated as follows: Customizing the Order Pipeline The following customizations can be made to a pipeline: A new service can be introduced into the pipeline, as long as a pickup status and drop status are defined. A new status can be defined, as long as the status is an extension of an existing status. For example, if a custom status of Fraud Reviewed is introduced in between Open and Allocated statuses, then Fraud Reviewed must be an extension of Open status, since the Allocate service works for any quantity in Open status. A new pipeline can be defined. A new branch in an existing pipeline can be added. Extending Other Pipelines When adding extended statuses to pipelines other than ship to home, there are some special considerations: The store sale pipeline has hard-coded logic to move units to Fulfilled status when the order is confirmed (isConfirmed is updated to true). If extended statuses are required between Open and Fulfilled status, then the order must be unconfirmed when moving through these statuses. Confirming the order will always move it to the Fulfilled status, regardless of the pipeline configuration. If you are modifying the store return pipeline, see above for the hard-coded logic for confirmation. In the store return pipeline, units automatically move to Returned status upon confirmation, but extended statuses can be used for unconfirmed orders. Order Status Order status is used to track the life cycle of an order and order lines. Numeric values are used for status values. A distinct set of statuses is defined for sale lines and for return lines; An order line status progresses from 1000 (Open) to 7000 (Fulfilled) status, and a return line travels from 11000 (Pending Return) to 18000 (Returned) status. Return Line Statuses with Carrier Scanned status: These numeric values are defined as the "base" statuses. You cannot modify or delete base statues. The following table defines the base statuses for sale order lines. Status ID Status Name Description 1000.000 Open Units have been created and not yet attempted for allocation. 1500.000 Back Ordered Units have been attempted for allocation but failed to get allocated due to inventory unavailability. 1600.000 Awaiting Procurement Units are out-of-stock and can be procured by the vendor. The status is config based, refer here for configuration. 2000.000 Allocated Units have been allocated and inventory has been reserved for it. 3000.000 Released Units have been released to the fulfillment system. 3500.000 In Process The fulfillment system has indicated to OM that the units are in-process. Hard-allocated in WM, Accepted by store fulfillment, and so on. 3600.000 Picked The units have been picked. 3700.000 Packed The units have been packed. 7000.000 Fulfilled Units have been fulfilled; this state includes both Shipped and Picked Up units. 7500.000 Delivered Units have been delivered to the customer. 8000.000 Pending Return The customer has initiated a return, but items have not been received by the retailer. 8500.000 Returned Units have been returned to the retailer. 9000.000 Canceled Order line has been canceled The following table contains the base statuses for return order lines. Status ID Status Name Description 11000.000 Pending Return The customer has initiated a return, but the items have not been received by the retailer 13000.000 Pending Approval Units are not in returnable condition but requires approval before a refund can be issued. 14000.000 Carrier Scanned Return labels are successfully carrier scanned. The system assumes that all quantities of all the return lines in the RO with isReceiptExpected = true are carrier scanned. Partial line or partial quantities are not allowed to be moved to this status. Return lines in the RO with isReceiptExpected = false cannot be moved to carrier scanned status 15000.000 Received Units have been received by the retailer, and return receiving is ongoing. 18000.000 Returned Units have been verified by the retailer and receiving is complete. 19000.000 Canceled Return Line has been canceled API for creating Carrier Scanned Status (14000)POST {{url}}/order/api/ServiceDefinition/statusDefinition/save { "ProcessTypeId": "RETURN_EXECUTION", "Status": "14000", "Description": "Carrier Scanned", "PartialStatusDescription": "Partially Carrier Scanned" } API for creating 'Awaiting Procurement' (1600) statusPOST {{url}}/order/api/ServiceDefinition/statusDefinition/save { "ProcessTypeId": "ORDER_EXECUTION", "Status": "1600", "Description": "Awaiting Procurement", "PartialStatusDescription": "Awaiting Partial Procurement" } Maintaining Order Status The order status is maintained at three different levels: unit-level, order line-level, and order-level. The entity which travels through the state transition is the unit, however it is useful to roll-up the unit-level status onto an order line and to roll up the order line status onto the order. The quantity detail entity is used to track unit-level status. Each order line can have between one and n quantity details, and one quantity detail record is required for each unique status of units on the order line. Each order line has two statuses maintained: a minimum fulfillment status and a maximum fulfillment status. The minimum fulfillment status is the minimum status across all quantity details, and the maximum fulfillment status is the maximum status across all quantity details. The line maximum fulfillment status does not reflect canceled status unless the entire line has been canceled. These two fields are used to maintain the status for both sale and return lines. Each order has four statuses maintained: a minimum fulfillment status, maximum fulfillment status, minimum return status, and maximum return status. The minimum fulfillment status is the minimum status across all sale order lines, and the maximum fulfillment status is the maximum status across all sale order lines. The minimum return status is the minimum status across all return order lines, and the maximum fulfillment status is the maximum status across all return order lines. The order maximum fulfillment status does not reflect canceled status unless the entire order has been canceled. Example 1: If a 3-unit order line has 1 unit which is backordered, 1 unit which is allocated, and 1 unit which is shipped, then three quantity detail records exist: 1 unit 1500.000 (Backordered) 1 unit 2000.000 (Allocated) 1 unit 7000.000 (Shipped) The order line minimum fulfillment status is 1500.000 (Backordered), and the maximum fulfillment status is 7000.000 (Shipped). The order minimum fulfillment status is 1500.000 (Backordered), and the maximum fulfillment status is 7000.000 (Shipped). The order minimum and maximum return statuses are null, as no return lines exist. Example 2: If a 3-unit return line has 2 units received and 1 unit which is still pending return receipt, then two quantity detail records exist: 1 unit 11000.000 (Pending Return) 2 unit 15000.000 (Received) The order line minimum fulfillment status is 11000.000 (Pending Return), and the maximum fulfillment status is 15000.000 (Received). The order minimum return status is 11000.000 (Pending Return), and the maximum return status is 15000.000 (Received). The order minimum and maximum fulfillment statuses are null, as no sale lines exist. Example 3: If a 2-line order has one line with the following quantity details: 1 unit 1500.000 (Backordered) 1 unit 2000.000 (Allocated) Then the order line minimum fulfillment status is 1500.000 (Backordered), and the maximum fulfillment status is 2000.000 (Allocated). If the second order line has the following quantity details: 1 unit 7000.000 (Shipped) Then the second order line minimum fulfillment status is 7000.000 (Shipped), and the maximum fulfillment status is 7000.000 (Shipped). The order minimum fulfillment status is 1500.000 (Backordered), and the maximum fulfillment status is 7000.000 (Shipped). The order minimum and maximum return statuses are null, as no return lines exist. There is one additional order line fulfillment status and an additional order fulfillment status attribute which gets calculated in run time and is used for displaying a single order status in the UI. For example, if an order has one line in "Shipped" status and a second line in "Allocated" status, then the order fulfillment status is "Partially Shipped". Delivered Order Status System can be configured to track delivery of packages shipped for order lines with Ship To Address or Ship To Store delivery methods in real time through APIs provided by third party carrier providers. Every package is assigned with a tracking number, and automatically moves the respective units shipped in a particular package associated to a tracking number to delivered status if the status of the package / tracking number moves to delivered in response received from the carrier. Refer to Delivery Tracking for details on how to configure the application for real time delivery tracking. Extended Order Statuses Extended statuses can be configured in the order state transition to track key business processes which are part of the order lifecycle. For example, if a retailer wants to perform a fraud check process before releasing orders, an extended status 'Fraud Check Passed' can be added after 'Allocated' status to invoke a fraud check service and cancel or release the order based on the results. Another use case is to track additional statuses after an order is released to downstream systems or post-delivery updates which are pushed to Manhattan Active® Omni from an external system. These extended statuses are tracked in the order quantity detail and rolled up to the order line and header fulfillment status. Extended statuses can be configured in any order pipeline, including ship to home, store sale, ship to return center, and digital goods. Outbound Publish Order and Publish Order Line messages can be triggered when quantity moves to a custom status. Extended statuses are visible in the Customer Service and Order List UIs. To define a custom status, each base status can be extended. An extended status is defined by adding a non-zero value after the decimal place. For example: Allocated/2000.000 can be extended to any value 2000.xxx (for example, 2000.100 for Fraud Check Passed) Released/3000.000 can be extended to any value 3000.xxx (for example, 3000.100 for Loaded on Truck) Fulfilled/7000.000 can be extended to any value 7000.xxx (for example, 7000.100 for Installed) Extended statuses must extend a base status. For example, a new extended status 33000.000 cannot be added, because this does not extend an existing base status. Note: The base statuses 9000 (Canceled) and19000 (Canceled) are not extendable. Any extended status should always be defined with a non-zero decimal value. Two mechanisms are provided for moving units to an extended status: via user exit invoked from Active Omni, or via an order event pushed from an external system. The below sections detail when each mechanism should be used. Moving Units to an Extended Status via User Exit This option should be implemented in scenarios where the business process should be initiated from Active Omni, as opposed to in an external system. For example, if a fraud check should be initiated immediately after allocation, then this option should be used. However, if a status update will be pushed from a WM system, then a user exit is not required, and an order event should be used instead. The extended status user exit accepts updates at the order line level. Here is how the state transition user exit moves units to a custom status: First, a custom service is configured in the state transition pipeline for this business process (for example, fraud check). In this custom service, a user exit is configured which will invoke the custom code. The response can be either synchronous or asynchronous. In the example of a fraud check, many fraud check systems respond asynchronously, in which case the custom code would pass an empty response to the user exit synchronously, then send a response later, when the update from the third-party fraud system is received. The user exit response contains updates such as order line and quantity, which moves the units to the extended status. The response can optionally contain updates to the order entity, including both out of the box attributes and extended attributes. For example, we could add two extended order attributes for fraud status and fraud reason in the fraud example and capture these attributes as part of the status update user exit response. A maximum of 15 user exits can be implemented for these custom state transition services. This means a maximum of 15 custom statuses which require user exits can be configured. The 15 limit does not include custom statuses which use the order event interface, since those statuses do not require a user exit. See Extended Order Status Configuration for details on how to configure an extended status user exit. Moving Units to an Extended Status via Order Event The second mechanism is via a push update from an external system using the Order Event interface. This is the same interface used to push updates from fulfillment systems such as shorts and shipments. This option should be used in scenarios where you want to track additional DC statuses or post-fulfillment statuses. The extended status user exit only accepts updates at the release line level. If order line updates are required, then the user exit needs to be implemented. Here is how the order event moves units to a custom status: The existing order event interface is used to pass updates at the release line level. This requires release Id, release line Id, and quantity. This looks just like the ship and short events from WM except that the event type will correspond to a custom pipeline service. Configuration exists to map the event type from the order event to the custom service in your pipeline. For example, if you had a custom “LoadTruck” service in the pipeline, your event type in the order event interface would be “LoadTruck”. No user exit is required for order event updates. The order event interface does not support updates to the full order entity like the user exit approach does. The order event only accepts updates to the fulfillment detail and its extended attributes. If order entities or attributes other than the quantity status, fulfillment detail, and fulfillment detail extended attributes need to be updated, then the state transition user exit needs to be implemented. For more information refer to the Configuration for Moving Units to an Extended Status and testing via Order Event sections in the Order Event guide. Order Pricing Order pricing consists of financial-related processes and services associated with an order. These processes can be broken down into four categories: Pricing: An order is priced by assigning a unique unit price to each order line. To price each line item, the Order component calls the Price and Promotion component. Charges: An order can have multiple different charges such as shipping and handling (S&H) and value-added service (VAS) charges at the order line and/or order level. Within the application, the Order component calculates S&H charges by calling the S&H component and VAS charges by calling the Item component. Charges are represented by using the order line charge detail and order charge detail entities. Discounts: Order can have multiple type of discounts, including promotion, coupon, discounts, and appeasements. Discounts and appeasements are manually applied to an order or order line. However, promotions and coupons are applied based on the configured promotions and coupons which are made available by the retailer. Promotions and coupons can be applied to orders by implementing a user exit to call an external promotions engine. No promotions or coupons are maintained in the application. Discounts can be applied at the line and header level and are represented by using the order line charge detail and order charge detail entities. Taxes: Tax is calculated for each taxable line item, including items S&H charges, VAS charges, and so on. Line and header-level taxes are calculated via integration between the Order component and a third-party tax engine. Refer to the tax portion of the Pricing guide for more information. Taxes are represented by using the order line tax detail and order tax detail entities. Note: If a charge has Is Informational = true on the order line charge detail, it will be considered for all the process in the order but is not counted in any totals like the Is Informational Tax. Order Update When certain order attributes are updated, it may be required to recalculate the item price, charges, discounts, or taxes. Other order updates may require re-evaluation of the inventory reservation, which is being held for the order, if key fulfillment attributes change. These order updates may also require an outbound order message to be published to alert external systems of the updates. For example, If a line shipping method changes from “Standard Delivery” to “2-Day Delivery” then S&H charges and taxes are recalculated, and the order line is re-allocated. If a line shipping address for a line changes from “New York” to “Los Angeles” then the order line is re-allocated based on the new destination. When an item is shipped, an order outbound message or outbound email message is published so that a third-party email marketing system can send the customer a shipment confirmation email. Changes to order attributes or groups of attributes are defined as a Modification Type, or "mod type". If the order is not getting saved after an update and throwing an error because a modification rule is preventing the update, the quick workaround is to temporarily modify the modification rule that is preventing the order update by logging in as system admin from the backend and complete the required order update and revert the changes done to the modification rules, if they are not intended to be permanent. Refer to Mod Types guide for more information. Order Version Timestamp Optionally, a Version Timestamp can be stamped on the order for version controlling order updates. The desired version number can be stamped on the order at the time of creating the order and can be updated or incremented every time the order is updated or modified via manual interface by mentioning the initial version and the incremental version number in order actions section as mentioned below. "OrderActions": { "VersionTimestamp": "123" } The order version is not updated for any internal order updates or modifications. The version number has to be an integer and cannot be an alphanumeric or decimal number. Once an order has a version stamped on it, the system will validate every subsequent order update or modification request interfaced in the system and will update or modify the order only if the incoming update or modification request has a version timestamp higher than the current version time stamp. Otherwise, the order is not updated or modified. The current version timestamp of the order is populated in the "VersionTimestamp" attribute on the order header and is also available on Publish Order message. If the order update request is interfaced with a non-integer version or stale version, the below mentioned error message is displayed. error.10208=Order {OrderId}, is bridged in with a stale/decremented or non integer version - {VersionToUpdate}. Once an order is stamped with a version timestamp, any external order update request should come with an incremented version number in the order actions. Otherwise, it will be considered as a stale/decremented version and order updates will fail with the above mentioned error message. When the order updates are bridged in without a 'VersionTimestamp' field or with "null" as the 'VersionTimestamp' value, the system accepts the updates by retaining the existing version timestamp. Order Confirmation In store sale transactions, once the order has been confirmed, Order Management will generate the RFID event (StoreSale) for updating the location unit inventory status from 'Available' to 'Departed' in RFID, which owns the master unit inventory. If the Store Sale Inventory Event is configured on the Inventory Update Config tab of the Order Parameters UI, Order Management will generate a store sale inventory event to decrease inventory at the store location. In store return transaction, once the order has been returned, Order Management will generate the RFID event (StoreSale) for updating the location unit inventory status from 'Available' to 'Departed' in RFID, which owns the master unit inventory. If the Store Return Inventory Event is configured on the Inventory Update Config tab of the Order Parameters UI, Order Management will generate a store return inventory event to increase inventory at the store location. Order Search A separate Search component exists to index order information for timely retrieval during search. The Search component uses an Elastic search to index every order in two steps: Every time an order is created, or index attributes are modified, the Order component puts a message into the Search component queue. The Search component picks up the message and invokes the Order component to get the latest copy of an order and index it. How to retrieve a list of return orders ? Order Search API can be utilized for this requirement to search for return orders associated with a parent order using OrderLine.ParentOrderId field. Refer to the API details mentioned below : Search based on the returnOrderId API : /order/api/order/order/search Request : { "Query" : "OrderId = 'R0000226234'", "Template":{ "OrderId" : null, "RelatedOrderIds" : null, "RelatedReturnIds" : null } } Response : { "Messages": null, "RelatedReturnIds": [], "RelatedOrderIds": [ "4117497590" ], "OrderId": "R0000226234" } Search based on the orderId API : /order/api/order/order/search Request : { "Query" : "OrderId = '4117497590'", "Template":{ "OrderId" : null, "RelatedOrderIds" : null, "RelatedReturnIds" : null } } Response : { "Messages": null, "RelatedReturnIds": [ "R0000226234" ], "RelatedOrderIds": [], "OrderId": "4117497590" } Note : While searching for a string having a wild character at the end of the string, the query returns all results which contain the matching string. For example, if a user is searching for an order number(on order list or order line list) with a value such as 0135*, the results will show all orders containing 0135 and not just orders starting with 0135. Orders cannot be queried using non-searchable fields like the JsonStore field. Configurations How to Set Up Order Type Configuration Each order is assigned one order type which is used to define unique business processes for each selling channel, brand, or other categories of orders. This order type controls the orchestration flow of each order, which means one unique order type should be created for each set of unique orchestration requirements. Each order type is assigned one order configuration. An order configuration can be shared across order types, if business requirements are common. For example, order types are defined for Brand 1 e-Commerce Orders, Brand 2 e-Commerce Orders, Brand 1 Replenishment Orders, and Brand 2 Replenishment Orders. Two order configurations are created: an e-Commerce Configuration which enables pricing, payment, and fulfillment services, and a Replenishment Configuration which disables pricing and payment services but enables fulfillment services. For this company, Brand 1 and Brand 2 have a common set of orchestration rules across all e-commerce orders and a separate set of rules which are common for both brands' replenishment orders. Therefore, in the order type configuration for Brand 1 e-Commerce Orders and Brand 2 e-Commerce Orders, both order types are assigned to the e-Commerce Configuration. In the order type configuration for Brand 1 Replenishment Orders and Brand 2 Replenishment Orders, both order types are assigned to the Replenishment Configuration. Order types are configured in the Order Type UI. Factors Affecting Order Configuration The order configuration is a set of parameters defined for orchestrating order pricing services, fulfillment services, and monitoring rules. Parameters included in the order configuration can be defined in three categories: General Configuration Modification Rules Order Monitoring How to Set up General Configurations The general configuration tab of the order configuration contains the parameters which enable or disable the selling services. These services are generally required for customer orders but can be disabled for retail replenishments or other orders which do not require financial processing. In general configuration section of the Order Configuration, the following services can be enabled or disabled for an order type. Price & Promotion: If this service is enabled, then orders created with this order type are sent to the Price and Promotion component to price each item. If this service is disabled, then the order capture system must provide an item price on order import, if a price is required. Shipping & Handling: If this service is enabled, then orders created with this order type are sent to the S&H component to calculate shipping charges. If this service is disabled, then the order capture system must provide S&H charges on order import, if S&H charges are required. Tax: If this service is enabled, then orders created with this order type are sent to the Vertex component and to the third-party tax provider to calculate taxes. If this service is disabled, then the order capture system must provide taxes on order import, if taxes are required. Payment: If this service is enabled, then orders created with this order type are sent to the Payment component to process payments, and invoicing is enabled. If this service is disabled, then orders created with this order type do not require payment processing by the payment component. For example, e-commerce and point of sale (POS) orders require pricing, S&H, tax, and payment services, but store transfer and replenishment orders do not require these services. To achieve this, the order configuration for e-commerce and POS orders enables these four services, while the order configuration for store transfer and replenishment order types disables these services. The selling services are configured on the General tab of the Order Configurations UI. The general configuration tab also includes parameters broken into categories like tax, invoicing, payment, sales posting, order publishing, returns, eInvoice, allocation, post release cancellation, ship it instead, delivery tracking, google shopping, archiving, and so on. The "Order configuration Additional" menu will contain additional configuration from the order configuration. They are not mandatory but are necessary for sequential invoice Id generation. See Invoicing & Sales Posting for more information. How to Configure Modification Rules A Modification Rule is used to configure the services which are required for each mod type. Refer to Mod Types for more information. The Modification Rule tab of the Order Configuration UI is used to configure modification rules for the following four categories: Order Level Modification Rules Order Line Level Modification Rules Return Line Level Modification Rules Quantity Level Modification Rules Extended Order Status Configuration The following table describes the extended status which is implemented via order event and user exit. To add an extended status which is implemented via the Order Event Interface Log in as system admin Add a custom Service Definition to be used in the pipeline (API only): {{url}}/order/api/ServiceDefinition/serviceDefinition/save Log in as a user in your organization and complete the remaining steps Add a custom status to the Status Definition entity (API only): {{url}}/order/api/ServiceDefinition/statusDefinition/save Add a mapping from Event Type to the Service Definition in the Extended Status Event Types UI. This maps the Event Type from the Order Event interface to the service definition in the pipeline. Update the pipeline to add your new status (API only): {{url}}/order/api/ServiceDefinition/pipeline/save To update an existing pipeline, make a GET call to retrieve the pipeline json. For example, to modify the ShipToHome pipeline, make a GET call to {{url}}/order/api/ServiceDefinition/pipeline/processTypeId/ORDER_EXECUTION/pipelineId/ShipToHome Modify the pipeline to add your service in two places: The PickupService and DropStatusDetermination. The PickupService defines which statuses each service can pick up from (for example, the Release service can pick up from Allocated status/2000). The DropStatus Determination defines which status a service will drop into, after completing (for example, the Release service drops in Released status/3000). Be sure to account for shorts, forward movements, and backwards movements. Optional - A new pipeline is only required if different orders should follow different life cycles which cannot be defined in the same pipeline. Sometimes this can be accomplished in a single pipeline. For example, if some ship to home orders go from Released > Loaded > Fulfilled, but others skip from Released > Fulfilled, then you do not need a new pipeline for this. A new pipeline is only required if a completely different life cycle is followed. To add a new pipeline: Add a rule action. This is used to map the rule to a pipeline. The rule action, rule condition, and rule are used to configure the pipeline filter condition, which determines which order lines should enter a given pipeline (API only): {{url}}/order/api/rules/ruleAction/save Add a rule condition (API only): {{url}}/order/api/rules/ruleCondition/save Add a rule which ties together your rule action and rule condition from the previous steps (API only): {{url}}/order/api/rules/rule/save Add a pipeline (API only): {{url}}/order/api/ServiceDefinition/pipeline/save To add an extended status which is implemented via a User Exit Log in as system admin, add a custom Service Definition to be used in the pipeline (API only): {{url}}/order/api/ServiceDefinition/serviceDefinition/save Log in as a user in your organization, add a custom status to the Status Definition entity (API only): {{url}}/order/api/ServiceDefinition/statusDefinition/save Create an Inbound Message Type which references the ServiceId from the previous step (API only): {{url}}/order/api/ServiceDefinition/inBoundMessageType/save Create an Outbound Message Type (API only): {{url}}/order/api/ServiceDefinition/outBoundMessageType/save Per standard user exit configuration - add an Extension Handler (API only): {{url}}/order/api/ServiceDefinition/extensionHandler/save Create a Service Definition for the user exit (API only): {{url}}/order/api/ServiceDefinition/serviceDefinition/save Update the pipeline (API only). See the "Update the pipeline" step within the user exit section for details: {{url}}/order/api/ServiceDefinition/pipeline/save Using Extended Statuses Extended statuses can be used in some application configurations, including: Status to release capacity Restrict from status in the order mod type configuration Extended statuses cannot be used in: The change status in the order mod type configuration; this must go through open Implementation Flavors Integration approach for Host sending 'full updates' Requirement: Integration approach for Host sending 'full updates', for example, HOST system like SAP accepts address update at order level for B2B orders. These orders can have multiple lines in different status like Allocated, Released and Fulfilled. When a full order update is sent for address update, MAO rejects this order because one or more lines may not be eligible for the update. The requirement is to accept the order update and process the same on eligible lines. Current: The behavior is to reject the order if any one of the lines in the request is not eligible. This design cannot be changed, hence recommending custom solution. Implementation: Option 1: MIF to break the incoming order request to contain only lines which are eligible for the update and push the updated order to MAO. This update should exclude lines which are not eligible. Option 2: Implement order extension handler to exclude the lines which are not eligible. How to maintain the same FulfillmentGroupId on addition of new line when all the lines are shipping to the same address Order is imported in the system with a fulfillmentGroupId populated on the order lines. When a new order line is added to the existing order by CSR with the same ship to address and wants to have the same FulfillmentGroupId populated for the new line as well, follow the below steps: Update OrderLine::AddressId and OrderLine::ShipToLocationId::ShipToStore Mod Types to have the following values: "ResubmitPipeline": true, "ChangeStatus": null "Calculate Snh": true FulfillmentGroupId updates to base generated value when CSR selects “Ship all Items Together” either updating or using the preexisting address on the order. How to change the order status description Retailers can change the order status description by following the steps below: Do a get of {{url}}/order/api/ServiceDefinition/statusDefinition Take the data for status : 7000 Change the “Description"  and "PartialStatusDescription" (Changes should be saved with existing PK) Save using below API API to update the status for 7000: {{url}}/order/api/ServiceDefinition/statusDefinition/save Sample data payload{ "Messages": null, "ProfileId": "ecomorg", "Status": "7000", "UpdatedTimestamp": "2023-08-07T10:33:28.518", "ProcessTypeId": "ORDER_EXECUTION", "Description": "Shipped", "CreatedBy": "admin@ecomorg.com", "CreatedTimestamp": "2023-08-07T10:33:28.518", "Process": "/fwcore/seeddata/import", "UpdatedBy": "admin@ecomorg.com", "PartialStatusDescription": "Partially Shipped", "ProcessType": { "ProcessTypeId": "ORDER_EXECUTION" }, "ContextId": "df3520a7-bb95-4b77-a533-3afb4ff7a0a3", "PK": "6914044085182864891", "Unique_Identifier": "6914044085182864891__7000__ORDER_EXECUTION" } Troubleshooting InvoiceLineTaxDetail missing Shipping Charge from the OrderLineTaxDetail Maintain Fulfillment Group Id, which is populated in Charges to taxes as well. Example: Fulfillment Group Id is populated for a given Shipping charge. When tax is computed for this charge, it creates OrderTaxDetail and prorated to OrderLineTaxDetails. If there is any customization involved where a custom service modifies or consolidates the OrderTaxDetail/OrderLineTaxDetail records for the same charge, then maintain the same Fulfillment Group Id in taxes as well. If the same Fulfillment Group Id which is present in Charge is not maintained in the respective tax records, then it will not be copied to Invoices. Is it possible to update order through bulk import API The bulkImport API supports the creation of new orders but does not support updating existing orders. Related Articles Order ArchivingOrder Orchestration ProcessOrder CancellationOrder TaggingCart and Preview ModePublishing Order Order Orchestration ConfigurationHoldsShipping RestrictionMod TypesOrder Audit Delivery Tracking