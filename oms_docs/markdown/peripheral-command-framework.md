# Peripheral Command Framework

**Permalink:** peripheral-command-framework
**Path:** Manhattan Active® Omni/Store/Process & Configuration Guides/Point of Sale/POS Guides/POS Payment/Peripheral Command Framework
**Content Length:** 56,258 characters
**Scraped:** 2025-08-09T22:02:09.629291

---

Home ››Manhattan Active® Omni››Store››Process & Configuration Guides››Point of Sale››POS Guides››POS Payment ››Peripheral Command Framework Peripheral Command Framework Previous I OverviewProcess FlowConfiguration flowCart Event and PCF designCart EventCart Event ConfigCart Event ConditionCommand GroupCommandCommand SequencePeripheral Template MapPeripheral Response MappingsOther FeaturesPause and Resume supportParallel Command executionBase Implementation of PCF Overview What is a Peripheral? Peripherals are external hardware components that extend the functionality of the Point of Sale application. These devices are connected to POS to provide additional features and improve overall business efficiency. Examples of common POS peripherals: Barcode scanners Printers Cash drawers Card readers Secondary Displays Payment Terminals Weighing Scales How does POS talk to the peripherals? The communication between the POS application layer and the peripheral happens via a plugin that is written to interact with the peripherals. For example, there is a specific plugin that is written for Payware for the POS application to interact with the payware terminal to accomplish functions like displaying line details on the terminals, requesting a capture or refund, etc. For each of these operations there are individual methods that are written in the plugin and each of the methods has the required commands that need to be sent to the payware payment terminal, thus making the plugin an integral part of the POS ecosystem. Challenges with existing Plugins: The MAO POS application delivers plugins out of the box for functions that are supported out of the box. However, during implementation, if there is a requirement to support some additional functions which the peripheral is capable of but the base application doesn't support, then the implementation team has to create a copy of the base plugin and then add new methods as needed and then start owning that plugin. The process of creating a new custom plugin has its own disadvantages. Implementation teams end up writing a lot of business logic into the plugins, which makes the plugins bulky and also do more work than what a plugin should typically do. The implementation team has to constantly keep up with any base changes made to the base plugin and re-applying those changes to the custom plugin. It takes time both to build the custom plugin and maintain the custom plugin. What is Peripheral Command Framework? As the variety of peripherals and their respective use cases continue to grow, and the challenges with custom plugins and implementation times, there is an increasing need for a more extensible interaction framework. The Peripheral Command Framework (PCF) is a structured process governing and orchestrating peripheral interactions within the Manhattan Active Omni® POS. This framework not only supports the seamless integration of various peripherals but also allows customers to implement and manage their own peripherals, enabling tailored interactions as required. The Peripheral Command Framework offers a new approach for implementation teams to interact with peripheral plugins. Below are some of the key objectives of the framework. Clear separation between business flows and native code(non-functional aspects of the app) Adding flexibility to the business flows that interact with the native plugins: The thought process is to drive the business flows through configuration. PCF would run through the configs and take appropriate actions based on the config. This makes the interactions completely flexible. The implementation teams will have to create configs based on business requirements. Please refer to the entity structure/example sections for more details on the configuration and its usage. Reducing the number of user exits. By making the flows flexible and configurable, the number of user exits can be reduced. Reducing the need for new builds/artifacts. The framework will provide the hooks or events required from the application to allow the custom implementation of a peripheral. Currently, the framework is capable of supporting custom plugins (not base) for payment on the iOS and Android platforms only.   Windows implementations are not supported, and the base Adyen and Payware connect interactions continue to follow their current legacy implementation. If a customer requires using a payment provider outside of Adyen / Payware, then a custom plugin can be created leveraging the Peripheral Interaction Framework (PCF). Currently the PCF supports only communication to the Customer Facing Display (CFD) and to Payment Terminals via custom plugin. Process Flow A new seed data API is introduced to load all the event config related to peripheral commands to seed data. A new peripheral command framework is introduced to orchestrate the whole interaction between UI and peripheral devices. When an event is raised in the UI, the UI performs the following evaluations and actions Check in the seed data if the event raised has a corresponding event config. If an event config exists, then evaluate the condition for the event config. All the event configs that match the conditions are picked. The event config with the lowest rank is then picked for execution. The periphalGroupId and the commandSequence is fetched for execution and the peripherals framework is invoked. The peripheral orchestrator performs the following actions The first command to be executed is identified as the command with IsInitial set to true. Once the first command is identified and the peripheral type associated is identified the orchestrator then passes the command along with the request and response template The plugin specific request is created and executed in the plugin and the response is transformed back based on the template. The orchestrator receives the response and based on the response, identifies the next command to be executed from the sequence. This process is continued until all the commands in the sequence are executed. If the event condition in the config doesn't match for the current order, then the UI proceeds further without invoking the orchestrator. Configuration flow The "Cart Event" and "cart event config" MUP UI screens will help the user to create and configure events for a defined condition. These conditions will be used to initiate the peripheral command framework. All the other configurations are currently only supported via API. Cart Event and PCF design There are many entities involved in this workflow, whilst the basic concept is that you define a trigger point which is an event and its conditions, and associate this event with peripheral interaction commands via command group. The sections below are entities involved in the cart event/ PCF design. Cart Event A cart event is a signal that something has happened, which could be initiated by user actions or system action.  Events are raised by the UI explicitly upon user action or system action. For example, a cart event can be raised when a user clicks on Checkout, scans an item etc. The cart event entity is a system entity and new events can only be added by R&D. A list of all available events will be seeded in the cartEvent entity. Each event will have a unit event Id and a description of when the event is raised. Sample events are as follows. CartEventId Description Objects passed with the event capturePayment This event is triggered when users click on the checkout button on the pos cart screen. export interface CapturePaymentCommandRequest extends PeripheralCommandRequest { data: { Order?: Order, PaymentSummary?: PaymentSummary, PaymentData?: PaymentResponse,// rename this to capturePaymentResponse PaymentMethod?:PaymentMethod[], CommandSequence?:CommandSequence, UniqueId?:string, Gateway?: GatewayDetail, IsAuth?: boolean, Response?:PaymentPluginResponse } } refundPayment This event is triggered when a user initiates adding a line to the cart, but before making the API call to the backend. export interface RefundPaymentCommandRequest extends PeripheralCommandRequest { data: { Order?: Order, PaymentSummary?: PaymentSummary, PaymentData?: RefundResponse, PaymentMethod?:PaymentMethod[], CommandSequence?:CommandSequence, UniqueId?:string, Gateway?: GatewayDetail, Response?:PaymentPluginResponse } } PostLineAdd PriceOverriden ItemQuantityUpdate DiscountApplied ItemTaxOverride ItemVASAdded PostTaxExempt This event is triggered when a user adds a line to the cart. export interface CaptureLineItemRequest extends PeripheralCommandRequest { data: { UpdatedOrderLine?: [], Order?: Order,cod OrderLineAttributeChanges?:[], UpdatedKeys?:[], CommandSequence?:any, Response?:PaymentPluginResponse } } capture-raise-event This event is triggered when the user receives a CapturePayment response indicating that PTT is set to true and implementation is local. It will be used for orchestrating interactions with the payment terminal. export interface CaptureRaiseEvent extends PeripheralCommandRequest { data: { order?: Order, request?: [], response?:[], eventName?:string } } voidPayment export interface VoidPaymentCommandRequest extends PeripheralCommandRequest { data:{ PaymentData:RequestToTerminal, PaymentMethod?:[], Response?:any, CommandSequence?:any } } PostAttachAssociate export interface postAttachAssociate { data: { SelectedAssociates: [], SelectedOrderLines: [] } } PostAttachCustomer export interface CustomerShippingAddress extends PeripheralCommandRequest { data: { CustomerShippingAddress?:ShippingAddress } } PreAttachCustomer PostAddAddress { data: { CustomerShippingAddress: shippingAddress } }; PreAddAddress { data: {PreAddAddress:{isAVSEnabled:                     shippingInformationCalculator?.isAVSEnable() } } } Cart Event Config Cart event config is the configuration that is used to configure what form group or command group should be invoked when an event is triggered. An event can have either a form group or a command group invoked. A condition can also be configured to control when the command group or form group should be invoked. It is possible to have different form groups or command groups for the same event based on the condition. However, if there is more than one event config available for one event, the rank is used and the lowest rank wins. The event conditions can be more than one. If there are more than one, then the matchAny attribute is used to define if all conditions have to match or not. If the MatchAny is false, then the conditions are treated as “AND” else “OR” Action type attribute defines if the event is triggering a form or a command group. Sample Configuration: cartEventConfigId cartEvent description actionType matchAny eventRank peripheralCommandGroup initialize-tap-to-pay tap-to-pay-initialize Event for initializing tap to pay PeripheralCommands true 1 taptopay-initialize Cart Event Condition Cart event condition configuration is to configure the conditions to be evaluated to determine if an event should invoke a command group. More than one condition can be defined for an event config. The event config is referenced here to return the list of all the conditions. For example, the use case may be to initialize tap to pay only if the gateway is AdyenPayments Sample Configuration: parentCartEventConfig conditionEntity attributeName attributeValue operator initialize-tap-to-pay data.payload GatewayId AdyenPayments = Command Group The Command group is the configuration that groups one or more related commands that are used to represent a business use case and creates the association between the commands. For example, if there is a requirement to auth and settle for a particular type of transaction, then a command group is configured for this business use case, and two commands are configured one for Authorization and another for Settlement. The event is configured to invoke a command group, and the command group will list all the commands associated to the group. Sample Configuration: peripheralCommandGroupId description taptopay-initialize Command group to initialize the tap to pay Adyen SDK Command The command configuration was introduced to capture the configuration for a command. A command is nothing but the actual command that has to be executed in the peripheral. A command contains a command id that is used to uniquely identify a command. For example, Capture can be a command for a payment terminal, which defines that the command is configured to execute a capture on the payment terminal. The command also has two important attributes: Request Template: The request template contains the actual request that needs to be sent to the terminal for executing the command. So, going by the example that we picked, the request template for the Capture command will contain the actual request that is required to execute the capture on the payment terminal. The Request template will have identifiers to replace with actual data. The actual data will be substituted during execution. Response Template: The response template contains the actual response that the base expects for that command to successfully update all the required objects on the MAO side. So, going by the example that we picked, the response template for the Capture command will contain the actual response that is required to record the settlement transaction in MAO. Service Id: A service can be invoked for a command if there is a need to massage the request or response before or after interacting with the peripheral. The implementation team can add any command as needed and provide the required request and response template. The other important attribute in the command configuration is the isInitial flag. This flag is set to true if the command is the first command to be executed, if the expected functionality requires more than one command to be executed in sequence. The Command configuration will be seeded with all the configurations that are required by base. Services and customers can create their own configurations as needed. Sample Configuration: PeripheralCommandTypeId PeripheralType PeripheralCommandId RequestTemplate ResponseTemplate IsInitial Settlement tapToPay contactless-settlement "{\r\n \"SaleToPOIRequest\": {\r\n \"PaymentRequest\": {\r\n \"SaleData\": {\r\n \"SaleToAcquirerData\": \"{{> SaleToAcquirerData | toBase64}}\",\r\n \"SaleTransactionID\": {\r\n \"TransactionID\": \"{{data.UniqueId}}\",\r\n \"TimeStamp\": \"{{data.Order.CreatedTimestamp | getISOTimeStamp}}\"\r\n }\r\n },\r\n \"PaymentTransaction\": {\r\n \"AmountsReq\": {\r\n \"Currency\": \"{{data.Order.CurrencyCode}}\",\r\n \"RequestedAmount\": {{data.PaymentData.Amount}}\r\n }\r\n },\r\n \"PaymentData\": {\r\n \"PaymentType\": \"Normal\"\r\n }\r\n },\r\n \"MessageHeader\": {{> AdyenMessageHeader}}\r\n }\r\n}" {\r\n \"ExternalResponseCode\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}\",\r\n \"Response\": {\r\n \"PaymentResponseStatus\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}\",\r\n \"PaymentResponseText\": \"\",\r\n \"PaymentMethod\": [\r\n {\r\n \"AccountDisplayNumber\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.MaskedPan}}\",\r\n \"AccountNumber\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.MaskedPan}}\",\r\n \"Amount\": \"{{data.PaymentData.Amount}}\",\r\n \"CardExpiryMonth\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.SensitiveCardData.ExpiryDate | sliceDate : \"month\"}}\",\r\n \"CardExpiryYear\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.SensitiveCardData.ExpiryDate | sliceDate : \"year\"}}\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType}}\r\n \"CardType\": {\"CardTypeId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType | map : \"CardType\"}}\" },\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType}}\r\n \"CurrencyCode\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.AmountsResp.Currency}}\",\r\n \"EntryTypeId\": \"Contactless\",\r\n \"GatewayId\": \"{{data.Gateway.GatewayId}}\",\r\n \"LocationId\": \"{{data.Order.SellingLocationId}}\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"NameOnCard\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"NameOnCard\": \"\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"PaymentMethodAttribute\": [],\r\n \"PaymentTransaction\": [\r\n {\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ExternalResponseId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ExternalResponseId\": null,\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"OrderId\": \"{{data.Order.OrderId}}\",\r\n \"PaymentResponseStatus\": {\r\n \"PaymentResponseStatusId\": \"{{#Response.SaleToPOIResponse}}{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}{{/Response.SaleToPOIResponse}}{{^Response.SaleToPOIResponse}}Failure{{/Response.SaleToPOIResponse}}\"\r\n },\r\n \"PaymentResponseText\": \"\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message}}\r\n \"PaymentResponseText\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message | safeValue : \"Unexpected Error\" }}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message}}\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message}}\r\n \"PaymentResponseText\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message | safeValue : \"Unexpected Error\" }}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message}}\r\n \"PaymentTransAttribute\": [\r\n {\r\n \"Name\": \"AcquirerTransactionID\",\r\n \"Value\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.transactionReferenceNumber | safeValue : \"N/A\"}}\"\r\n }\r\n ],\r\n \"PaymentTransEncrAttribute\": [],\r\n \"PaymentTransactionEMVTags\": {\r\n \"Emv4F\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.AID}}\",\r\n \"Emv9F06\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.AID}}\",\r\n \"Emv9F12\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.applicationPreferredName}}\",\r\n \"Emv9F21\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.txtime}}\",\r\n \"Emv9C\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.transactionType}}\",\r\n \"Emv9A\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.txdate}}\",\r\n \"Emv9F39\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.posEntryMode}}\",\r\n \"Emv50\": \"\",\r\n \"EmvCvm\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderVerificationMethodResults}}\",\r\n \"TacOnline\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.offline}}\",\r\n \"TermId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.mid}}\"\r\n },\r\n \"PaymentTransactionId\": \"{{data.UniqueId}}\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ProcessedAmount\": 0,\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ProcessedAmount\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.posAuthAmountValue| formatCurrency}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ReconciliationId\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentAcquirerData.ApprovalCode}}\",\r\n \"RequestId\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TransactionID | splitByDot:1}}\",\r\n \"RequestToken\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TransactionID | splitByDot:0}}\",\r\n \"RequestedAmount\": \"{{data.PaymentData.Amount}}\",\r\n \"RequestedDate\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TimeStamp}}\",\r\n \"Status\": {\r\n \"PaymentTransactionStatusId\": \"Closed\"\r\n },\r\n \"TransactionDate\": \"{{Response.SaleToPOIResponse.PaymentResponse.SaleData.SaleTransactionID.TimeStamp}}\",\r\n \"TransactionType\": {\r\n \"PaymentTransactionTypeId\": \"Settlement\"\r\n },\r\n \"TransmissionStatus\": {\r\n \"PaymentTransmissionStatusId\": \"Closed\"\r\n }\r\n }\r\n ],\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n \"PaymentType\": {\r\n \"PaymentTypeId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource | map : \"PaymentType\"}}\"\r\n }\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n \"PaymentType\": {\r\n \"PaymentTypeId\": \"{{data.PaymentData.PaymentType}}\"\r\n }\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n }\r\n ]\r\n}\r\n}" true Command Sequence The command sequence configuration is used to configure the sequence of commands and how the commands must be orchestrated. Even if there is only one command group, the response for the command group can be handled differently and different actions taken based on the response code. So the command sequence is a composer for the framework to build the conditional orchestration. The nextPeripheralCommandId attribute is used to define what is the next command that should be executed in the peripheral. If there is no command to execute further then the field is left as null. Sample Configuration: responseType responseCode nextPeripheralCommandId Success 200 Settlement Failure 4XX null Request URL: /posservice/api/posservice/peripheralCommandGroup/save Request Payload: Command Save - Request Payload { "PeripheralCommandGroupId": "taptopay-settlement", "PeripheralCommand": [ { "PeripheralCommandTypeId": { "CommandTypeId": "Settlement" }, "PeripheralType": "tapToPay", "PeripheralCommandId": "contactless-settlement", "ResponseTemplate": "{\r\n  \"ExternalResponseCode\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}\",\r\n \"Response\": {\r\n    \"PaymentResponseStatus\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}\",\r\n \"PaymentResponseText\": \"\",\r\n    \"PaymentMethod\": [\r\n      {\r\n \"AccountDisplayNumber\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.MaskedPan}}\",\r\n \"AccountNumber\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.MaskedPan}}\",\r\n \"Amount\": \"{{data.PaymentData.Amount}}\",\r\n \"CardExpiryMonth\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.SensitiveCardData.ExpiryDate | sliceDate : \"month\"}}\" ,\r\n \"CardExpiryYear\": \ "{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentInstrumentData.CardData.SensitiveCardData.ExpiryDate | sliceDate : \"year\"}}\", \r\n        {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType}}\r\n \"CardType\": {\"CardTypeId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType | map : \"CardType\"}}\" },\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardType}}\r\n \"CurrencyCode\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.AmountsResp.Currency}}\",\r\n \"EntryTypeId\": \"Contactless\",\r\n        \"GatewayId\": \"{{data.Gateway.GatewayId}}\",\r\n \"LocationId\": \"{{data.Order.SellingLocationId}}\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"NameOnCard\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"NameOnCard\": \"\",\r\n        {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderName}}\r\n \"PaymentMethodAttribute\": [],\r\n        \"PaymentTransaction\": [\r\n          {\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ExternalResponseId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ExternalResponseId\": null,\r\n            {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"OrderId\": \"{{data.Order.OrderId}}\",\r\n            \"PaymentResponseStatus\": {\r\n \"PaymentResponseStatusId\": \ "{{#Response.SaleToPOIResponse}}{{Response.SaleToPOIResponse.PaymentResponse.Response.Result}}{{/Response.SaleToPOIResponse}}{{^Response.SaleToPOIResponse}} Failure{{/Response.SaleToPOIResponse}}\"\r\n            },\r\n            \"PaymentResponseText\": \"\",\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message}}\r\n \"PaymentResponseText\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message | safeValue : \"Unexpected Error\" }}\", \r\n            {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.message}}\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message}}\r\n \"PaymentResponseText\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message | safeValue : \"Unexpected Error\" }}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.message}}\r\n \"PaymentTransAttribute\": [\r\n              {\r\n                \"Name\": \"AcquirerTransactionID\",\r\n \"Value\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.transactionReferenceNumber | safeValue : \"N/A\"}}\"\r\n }\r\n            ],\r\n            \"PaymentTransEncrAttribute\": [],\r\n            \"PaymentTransactionEMVTags\": {\r\n \"Emv4F\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.AID}}\",\r\n \"Emv9F06\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.AID}}\",\r\n \"Emv9F12\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.applicationPreferredName}}\",\r\n \"Emv9F21\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.txtime}}\",\r\n \"Emv9C\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.transactionType}}\",\r\n \"Emv9A\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.txdate}}\",\r\n \"Emv9F39\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.posEntryMode}}\",\r\n \"Emv50\": \"\",\r\n \"EmvCvm\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.cardHolderVerificationMethodResults}}\",\r\n \"TacOnline\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.offline}}\",\r\n \"TermId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.mid}}\"\r\n            },\r\n \"PaymentTransactionId\": \"{{data.UniqueId}}\",\r\n            {{#Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n \"ProcessedAmount\": 0,\r\n            {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n            \"ProcessedAmount\": \ "{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.posAuthAmountValue| formatCurrency}}\",\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.ErrorCondition}}\r\n            \"ReconciliationId\": \"{{Response.SaleToPOIResponse.PaymentResponse.PaymentResult.PaymentAcquirerData.ApprovalCode}}\",\r\n \"RequestId\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TransactionID | splitByDot:1}}\",\r\n \"RequestToken\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TransactionID | splitByDot:0}}\",\r\n \"RequestedAmount\": \"{{data.PaymentData.Amount}}\",\r\n \"RequestedDate\": \"{{Response.SaleToPOIResponse.PaymentResponse.POIData.POITransactionID.TimeStamp}}\",\r\n \"Status\": {\r\n              \"PaymentTransactionStatusId\": \"Closed\"\r\n            },\r\n \"TransactionDate\": \"{{Response.SaleToPOIResponse.PaymentResponse.SaleData.SaleTransactionID.TimeStamp}}\",\r\n \"TransactionType\": {\r\n              \"PaymentTransactionTypeId\": \"Settlement\"\r\n            },\r\n \"TransmissionStatus\": {\r\n              \"PaymentTransmissionStatusId\": \"Closed\"\r\n            }\r\n          }\r\n        ],\r\n {{#Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n \"PaymentType\": {\r\n          \"PaymentTypeId\": \"{{Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource | map : \"PaymentType\"}}\"\r\n }\r\n        {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n {{^Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n \"PaymentType\": {\r\n          \"PaymentTypeId\": \"{{data.PaymentData.PaymentType}}\"\r\n        }\r\n {{/Response.SaleToPOIResponse.PaymentResponse.Response.AdditionalResponse.additionalData.fundingSource}}\r\n      }\r\n  ]\r\n}\r\n}", "PeripheralCommandSequence": [], "RequestTemplate": "{\r\n  \"SaleToPOIRequest\": {\r\n    \"PaymentRequest\": {\r\n      \"SaleData\": {\r\n \"SaleToAcquirerData\": \"{{> SaleToAcquirerData | toBase64}}\",\r\n        \"SaleTransactionID\": {\r\n \"TransactionID\": \"{{data.UniqueId}}\",\r\n          \"TimeStamp\": \"{{data.Order.CreatedTimestamp | getISOTimeStamp}}\"\r\n        }\r\n      }, \r\n      \"PaymentTransaction\": {\r\n        \"AmountsReq\": {\r\n          \"Currency\": \"{{data.Order.CurrencyCode}}\",\r\n \"RequestedAmount\": {{data.PaymentData.Amount}}\r\n        }\r\n      },\r\n      \"PaymentData\": {\r\n        \"PaymentType\": \"Normal\"\r\n }\r\n    },\r\n    \"MessageHeader\": {{> AdyenMessageHeader}}\r\n  }\r\n}" } ] } Peripheral Template Map Template map is a configuration that allows implementation teams to configure values that need to be translated in the request while sending the request to the peripheral or vice versa. For example, lets say in MAO the card types are configured as Visa, Master Card etc and the payment gateway expects the values to be VI and MC, then the key and values can be configured in the template map along with a group name. The group name must be referenced in the request template or the response template in the command configuration. This can be used in both the request and response templates and eliminates code to handle these translations. The group name is used by the framework to identify which keys to pick and replace. Sample Configuration: GroupName TemplateKey TemplateValue CardType MC MasterCard CardType MASTERCARD MasterCard Request URL: /posservice/api/posservice/peripheralTemplateMap/save Request Payload: { "GroupName": "CardType", "TemplateKey": "MASTERCARD", "TemplateValue": "MasterCard" } Peripheral Response Mappings A new process to map individual peripheral responses to a standard base response. A new configuration has been introduced to allow response mappings to be defined. A set of generalized response codes and descriptions are introduced from base as a separate configuration. The peripheral response mapping will allow mapping a specific response code from a peripheral to the generic base response codes. Custom implementation will configure the required mappings in the peripheral response mappings as needed. Sample Configuration (Peripheral Response Mapping): PeripheralTypeId ExternalResponseCode InternalResponseCode tapToPay Success Success Sample Configuration (Peripheral Response Code): ResponseType ResponseDecision Description InternalResponseCode Message Success Success Tap to pay payment successfully approved Success Tap to pay payment successfully approved Other Features Pause and Resume support The framework supports use cases where the interaction with the peripheral also involves executing something in the application before proceeding further with the peripheral interaction. In essence, we can execute a service in the middle of a peripheral interaction. A custom service that is registered in the service registry can be executed while executing a command in the peripheral. The framework is able to pause the peripheral interaction and execute the service and, after executing the service, the peripheral interaction can be resumed. Parallel Command execution PCF is capable of supporting parallel execution of commands. For example, when items are added to the cart, it may be required to display the items in the payment terminal as well as the customer-facing display. In this scenario, there can be two commands configured for the same event with the same rank but with different peripheral types. The commands are orchestrated in each peripheral in parallel. Base Implementation of PCF Customer-facing display Tap to Pay Support for custom plugins in iOS and Android